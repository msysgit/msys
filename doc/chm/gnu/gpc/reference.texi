@c Copyright (C) 1997-2002 Free Software Foundation, Inc.
@c For copying conditions, see the file gpc.texi.
@c This file is part of the GPC Manual.
@c
@c Authors: Dominik Freche <dominik.freche@mailbox.tu-dresden.de>
@c          Peter Gerwinski <peter@gerwinski.de>
@c          Frank Heckenbach <frank@pascal.gnu.de>
@c
@c Last modification: 2002-05-10 (file under construction)

@node Reference
@chapter The Alphabetical GPC Language Reference

@strong{This chapter is still under development. All identifiers are
listed, but not all with explanations.}

This chapter contains an alphabetical list of all built-in
identifiers of the GNU Pascal compiler. For detailed and
comprehensive description of syntax and reserved words, see
@ref{Programming}. This chapter explains only built-in procedures
and functions in detail. It does not cover extensions provided by
external units and libraries which are supposed to come with their
own documentation.

@c This table indeed lists all identifiers currently recognized
@c *and supported* by GPC.
@c
@c Most of the entries point to skeletons. Once we have documented all
@c of the below, we have a more-or-less complete documentation for GPC.

@menu
* Abs::
* absolute::
* abstract::
* Addr::
* AlignOf::
* all::
* and::
* and then::
* and_then::
* AnsiChar::
* Append::
* ArcTan::
* Arg::
* array::
* as::
* asm::
* asmname::
* Assign::
* Assigned::
* attribute::
* begin::
* Bind::
* bindable::
* Binding::
* BindingType::
* BitSizeOf::
* BlockRead::
* BlockWrite::
* Boolean::
* Break::
* Byte::
* ByteBool::
* ByteCard::
* ByteInt::
* C::
* Card::
* Cardinal::
* case::
* Char::
* ChDir::
* Chr::
* c_language::
* class::
* Close::
* Cmplx::
* Comp::
* Complex::
* Concat::
* Conjugate::
* const::
* constructor::
* Continue::
* Copy::
* Cos::
* CString::
* CString2String::
* CStringCopyString::
* Date::
* Dec::
* DefineSize::
* Delete::
* destructor::
* Dispose::
* div::
* do::
* Double::
* downto::
* else::
* Empty::
* end::
* EOF::
* EOLn::
* EpsReal::
* EQ::
* Erase::
* Exclude::
* Exit::
* Exp::
* export::
* exports::
* Extend::
* Extended::
* extern::
* external::
* Fail::
* False::
* far::
* file::
* FileMode::
* FilePos::
* FileSize::
* FillChar::
* Finalize::
* Flush::
* for::
* FormatString::
* forward::
* Frac::
* FrameAddress::
* FreeMem::
* function::
* GE::
* Get::
* GetMem::
* GetTimeStamp::
* goto::
* GT::
* Halt::
* High::
* if::
* Im::
* implementation::
* import::
* in::
* Inc::
* Include::
* Index::
* inherited::
* Initialize::
* inline::
* InOutRes::
* Input::
* Insert::
* Int::
* Integer::
* interface::
* interrupt::
* IOResult::
* is::
* label::
* LastPosition::
* LE::
* Length::
* library::
* Ln::
* LoCase::
* LongBool::
* LongCard::
* LongestBool::
* LongestCard::
* LongestInt::
* LongestReal::
* LongestWord::
* LongInt::
* LongReal::
* LongWord::
* Low::
* LT::
* Mark::
* Max::
* MaxChar::
* MaxInt::
* MaxReal::
* MedBool::
* MedCard::
* MedInt::
* MedReal::
* MedWord::
* Min::
* MinReal::
* MkDir::
* mod::
* module::
* Move::
* MoveLeft::
* MoveRight::
* Name::
* NE::
* near::
* New::
* NewCString::
* nil::
* not::
* Null::
* object::
* Odd::
* of::
* only::
* operator::
* or::
* Ord::
* or else::
* or_else::
* otherwise::
* Output::
* Override::
* Pack::
* packed::
* Page::
* PAnsiChar::
* ParamCount::
* ParamStr::
* PChar::
* Pi::
* PObjectType::
* Pointer::
* Polar::
* Pos::
* Position::
* pow::
* Pred::
* private::
* procedure::
* program::
* property::
* protected::
* PtrCard::
* PtrDiffType::
* PtrInt::
* PtrWord::
* public::
* published::
* Put::
* qualified::
* Random::
* Randomize::
* Re::
* Read::
* ReadLn::
* ReadStr::
* Real::
* record::
* register::
* Release::
* Rename::
* repeat::
* Reset::
* resident::
* restricted::
* Result::
* Return::
* ReturnAddress::
* Rewrite::
* RmDir::
* Root::
* Round::
* RunError::
* Seek::
* SeekRead::
* SeekUpdate::
* SeekWrite::
* segment::
* Self::
* set::
* SetFileTime::
* SetLength::
* SetType::
* shl::
* ShortBool::
* ShortCard::
* ShortInt::
* ShortReal::
* ShortWord::
* shr::
* Sin::
* Single::
* SizeOf::
* SizeType::
* SmallInt::
* Sqr::
* SqRt::
* StandardError::
* StandardInput::
* StandardOutput::
* static::
* StdErr::
* Str::
* String::
* String2CString::
* SubStr::
* Succ::
* Text::
* TextWritable::
* then::
* Time::
* TimeStamp::
* to::
* to begin do::
* to end do::
* Trim::
* True::
* Trunc::
* Truncate::
* type::
* type of::
* TypeOf::
* Unbind::
* unit::
* Unpack::
* until::
* UpCase::
* Update::
* uses::
* Val::
* value::
* var::
* view::
* virtual::
* Void::
* volatile::
* while::
* with::
* Word::
* WordBool::
* Write::
* WriteLn::
* WriteStr::
* xor::
@end menu


@c ============================================================================


@node Abs
@unnumberedsec Abs
@cindex Abs

@subheading Synopsis

@example
function Abs (i: @var{integer type}): @var{integer type};
@end example
or
@example
function Abs (x: @var{real type}): @var{real type};
@end example
or
@example
function Abs (z: @var{Complex type}): @var{real type};
@end example

@subheading Description

Returns the absolute value of the argument. For integer or real
values of @samp{x}, the definition is

@example
function Abs (x: @var{integer or real type}): @var{integer or real type};
begin
  if x < 0 then
    Abs := -x
  else
    Abs := x
end;
@end example

@noindent whereas for complex values it is

@example
function Abs (x: Complex): Real;
begin
  Abs := SqRt (x * Conjugate (x))
end;
@end example

@subheading Conforming to

The function @samp{Abs} is defined in ISO-7185 Pascal; its
application to complex values is defined in ISO-10206 Extended
Pascal.

@subheading Example

@example
program AbsDemo;
var
  i1: Complex;
begin
  WriteLn (Abs (42));             @{ 42 @}
  WriteLn (Abs (-42));            @{ 42 @}
  WriteLn (Abs (-12.1) : 0 : 1);  @{ 12.1 @}
  i1 := Cmplx (1, 1);             @{ 1 + i @}
  WriteLn (Abs (i1) : 0 : 3)      @{ 1.414, i.e. SqRt (2) @}
end.
@end example

@subheading See also

@ref{Sqr}.


@c ----------------------------------------------------------------------------


@node absolute
@unnumberedsec absolute
@cindex absolute

@subheading Synopsis

@example
var
  @var{variable name}: @var{data type} absolute @var{variable reference};
@end example
or
@example
var
  @var{variable name}: @var{data type} absolute @var{integer expression};
@end example

@subheading Description

The first meaning of the @samp{absolute} directive allows to put a
variable to the address of another one and thus provides a
type-casting mechanism.

In most cases, @var{variable reference} will be just a variable
name, but GPC also allows arbitrary pointer expressions here. If
@var{variable reference} has neither a constant address nor is a
variable parameter, GPC prints a warning. This warning is suppressed
in ``extended syntax'' mode which is switched on by the
@samp{--extended-syntax} option or the @samp{@{$X+@}} compiler
directive.

GPC also allows explicit type casts. Variant records (as defined in
ISO-7185 Pascal), however, have no @emph{guaranteed} overlaying and
are therefore @emph{not} suitable for type casts.

The second meaning of @samp{absolute} places a variable at a
specified address. This is useful on machines without virtual memory
addressing for doing certain low-level operations, but should be
avoided on systems with memory protection such as Unix-like systems.
GPC does not check whether the specified virtual address makes any
sense and does not provide a built-in mechanism to map it to a real
address.

GPC warns about this second use of @samp{absolute} unless ``extended
syntax'' has been requested.

@subheading Conforming to

@samp{absolute} is a Borland Pascal extension.

Borland Pascal has a slightly different syntax for the second
meaning related to the addressing scheme of IA32 processors working
in real mode.

Allowing arbitrary memory references instead of just variable names
in the first meaning of @samp{absolute} is a GNU Pascal extension.

@subheading Example

@example
program AbsoluteDemo;

@{$X+@}

const
  IOMem = $f0000000;

var
  Mem: array [0 .. High (Cardinal)] of Byte absolute 0;

  @{ This address has no actual meaning @}
  MyPort: Byte absolute IOMem + $c030;

@{ Beware: Using any of the variables above will crash
  your program unless you know exactly what you do!
  That's why GPC warns about it without the $X+ directive. @}

var
  x: Real;
  a: array [1 .. SizeOf (Real)] of Byte absolute x;
  i: Integer;
  b: Byte absolute a[i];  @{ GNU extension: non-constant memory reference. @}

begin
  x := 3.14;

  @{ Look at the internal representation of a real variable. @}
  for i := 1 to SizeOf (Real) do
    Write (a[i] : 4);
  WriteLn;

  @{ The same again, more ugly ... @}
  for i := 1 to SizeOf (Real) do
    Write (b : 4);
  WriteLn;

  @{ And yes, there's an even more ugly way to do it ... @}
  for i := 1 to SizeOf (Real) do
    Write (Mem[PtrCard (@@x) + i - 1] : 4);
  WriteLn
end.
@end example

@subheading See also

@ref{record}, @ref{Type Casts}.


@c ----------------------------------------------------------------------------


@node abstract
@unnumberedsec abstract
@cindex abstract

Not yet implemented.

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Addr
@unnumberedsec Addr
@cindex Addr

@subheading Synopsis

@example
function Addr (const Foo): Pointer;
@end example

@subheading Description

@samp{Addr} returns the address of its argument. It is equivalent to the
address operator and provided for compatibility with Borland Pascal
which in turn implements it for backward-compatibility with Turbo
Pascal.

@subheading Conforming to

@samp{Addr} is a Borland Pascal extension.

@subheading Example

@example
program AddrDemo;
var
  Foo: ^Integer;
  Bar: Integer;
begin
  Foo := Addr (Bar);  @{ Let `Foo' point to `Bar'. @}
  Bar := 17;
  Foo^ := 42;  @{ Change the value of `Bar' to 42 @}
  WriteLn (Bar)
end.
@end example

@subheading See also

@ref{Operators}.


@c ----------------------------------------------------------------------------


@node AlignOf
@unnumberedsec AlignOf
@cindex AlignOf
@cindex alignment

@subheading Synopsis

@example
function AlignOf (var x): Integer;
@end example

@subheading Description

Returns the alignment of a type or variable in bytes.

@subheading Conforming to

@samp{AlignOf} is a GNU extension.

@subheading Example

@example
program AlignOfDemo;
var
  a: Integer;
  b: array [1 .. 8] of Char;
begin
  WriteLn (AlignOf (a));        @{ Alignment of `Integer'; usually 4 bytes. @}
  WriteLn (AlignOf (Integer));  @{ The same. @}
  WriteLn (AlignOf (b));        @{ Alignment of `Char'; usually 1 byte. @}
end.
@end example

Although the array is bigger than a single char, it is accessed char by char,
so there usually is no need to align it on a 4 byte boundary or such.  (This
may be false on some platforms.)

@subheading See also

@ref{SizeOf}, @ref{BitSizeOf}, @ref{TypeOf}.


@c ----------------------------------------------------------------------------


@node all
@unnumberedsec all
@cindex all

@subheading Synopsis

@example
export foo = all;
@end example

@subheading Description

@samp{all} is a predefined export interface for Extended Pascal modules.
You can use it to export all identifiers declared in an interface module
automatically.

@subheading Conforming to

@samp{All} is a GNU extension.

@subheading Example

@example
program AllDemo;

import AllInterface in 'allmodule.pas';

begin
  Bar (a);
  WriteLn (b)
end.
@end example

@example
module AllModule interface;

export
  AllInterface = all;  @{ Same as `AllInterface = (a, b, Bar);' @}

var
  a, b: Integer;

procedure Bar (i: Integer);

end.

module AllModule implementation;

procedure Bar (i: Integer);
begin
  b := a
end;

to begin do
  a := 42;

end.
@end example

@subheading See also

@ref{Modules}.


@c ----------------------------------------------------------------------------


@node and
@unnumberedsec and
@cindex and

@subheading Synopsis

@example
operator and (operand1, operand2: Boolean) = Result: Boolean;
@end example
or
@example
operator and (operand1, operand2: @var{integer type}) = Result: @var{integer type};
@end example
or
@example
procedure and (var operand1: @var{integer type}; operand2: @var{integer type});
@end example

@subheading Description

In GNU Pascal, @samp{and} has three built-in meanings:

@enumerate

@item
Logical ``and'' between two @samp{Boolean}-type expressions.
The result of the operation is of @samp{Boolean} type.

By default, @samp{and} acts as a short-circuit operator in GPC:  If the first
operand is @samp{False}, the second operand is not evaluated because the result
is already known to be @samp{False}. You can change this to complete
evaluation using the @samp{--no-short-circuit} command-line option or the
@samp{@{$B+@}} compiler directive.

@item
Bitwise ``and'' between two integer-type expressions.
The result is of the common integer type of both expressions.

@item
Use as a ``procedure'':  @samp{operand1} is ``and''ed bitwise with
@samp{operand2}; the result is stored in @samp{operand1}.

@end enumerate

@subheading Conforming to

The logical @samp{and} operator is defined in ISO-7185 Pascal.

According to ISO, you cannot rely on @samp{and} being a short-circuit
operator.  On the other hand, GPC's default behaviour does @emph{not}
contradict the ISO standard.  (See @ref{and_then}.)  However, since it seems
to be a de-facto standard among ISO Pascal compilers to evaluate both
operands of @samp{and}, GPC switches to @samp{--no-short-circuit} mode if
one of the language dialect options selecting ISO Pascal, for instance
@samp{--extended-pascal}, is given.  Use @samp{--short-circuit} to override.

Use of @samp{and} as a bitwise operator for integers is a Borland Pascal
extension.

Use of @samp{and} as a ``procedure'' is a GNU extension.

@subheading Example

@example
program AndDemo;
var
  a, b, c: Integer;
begin
  if (a = 0) and (b = 0) then  @{ logical `and' @}
    c := 1
  else if a and b = 0 then  @{ bitwise `and' @}
    c := 2
  else
    and (c, a)  @{ same as `c := c and a' @}
end.
@end example

Note the difference between the logical @samp{and} and the bitwise
@samp{and}:  When @samp{a} is 2 and @samp{b} is 4, then @samp{a and b} is 0.
@strong{Beware:}  @samp{a and b = 0} has nothing to do with
@samp{(a = 0) and (b = 0)}!

Since bitwise @samp{and} has a higher priority than the @samp{=} operator,
parentheses are needed in @samp{if (a = 0) and (b = 0)} because otherwise
@samp{0 and b} would be calculated first, and the remainder would cause a
parse error.

@subheading See also

@ref{and_then}, @ref{and then}, @ref{or}, @ref{xor}, @ref{Operators}.


@c ----------------------------------------------------------------------------


@node and then
@unnumberedsec and then
@cindex and then

@subheading Synopsis

@example
@{ `and then' is built in. A user-defined operator cannot consist of
   two words. @}
operator and then (operand1, operand2: Boolean) = Result: Boolean;
@end example

@subheading Description

@samp{and then} is an alias for the short-circuit logical operator
@samp{and_then}.

@subheading Conforming to

While @samp{and_then} is defined in ISO-10206 Extended Pascal,
@samp{and then} is a GNU Extension.

@subheading Example

@example
program AndThenDemo;
var
  p: ^Integer;
begin
  New (p);
  ReadLn (p^);
  if (p <> nil) and then (p^ < 42) then  @{ This is safe. @}
    WriteLn (p^, ' is less than 42')
end.
@end example

@subheading See also

@ref{and_then}, @ref{and}, @ref{or else}.


@c ----------------------------------------------------------------------------


@node and_then
@unnumberedsec and_then
@cindex and_then

@subheading Synopsis

@example
operator and_then (operand1, operand2: Boolean) = Result: Boolean;
@end example

@subheading Description

The @samp{and_then} short-circuit logical operator performs the same
operation as the logical operator @samp{and}.  But while the ISO standard
does not specify anything about the evaluation of the operands of @samp{and}
-- they may be evaluated in any order, or not at all -- @samp{and_then} has
a well-defined behaviour:  It evaluates the first operand.  If the result is
@samp{False}, @samp{and_then} returns @samp{False} without evaluating the
second operand.  If it is @samp{True}, the second operand is evaluated and
returned.

Since the behaviour described above is the most efficient way to implement
@samp{and}, GPC by default treats @samp{and} and @samp{and_then} exactly the
same.  If you want, for some reason, to have both operands of @samp{and}
evaluated completely, you must assign both to temporary variables and then
use @samp{and} -- or @samp{and_then}, it does not matter.

@subheading Conforming to

@samp{and_then} is an ISO-10206 Extended Pascal extension.

Some people think that the ISO standard requires both operands of
@samp{and} to be evaluated.  This is false.  What the ISO standard
@emph{does} say is that you cannot rely on a certain order of
evaluation of the operands of @samp{and}; in particular things like
the following program can crash according to ISO Pascal, although
they cannot crash when compiled with GNU Pascal running in default
mode.

@example
program AndBug;
var
  p: ^Integer;
begin
  New (p);
  ReadLn (p^);
  if (p <> nil) and (p^ < 42) then  @{ This is NOT safe! @}
    WriteLn ('You''re lucky. But the test could have crashed ...')
end.
@end example

@subheading Example

@example
program And_ThenDemo;
var
  p: ^Integer;
begin
  New (p);
  ReadLn (p^);
  if (p <> nil) and_then (p^ < 42) then  @{ This is safe. @}
    WriteLn (p^, ' is less than 42')
end.
@end example

@subheading See also

@ref{and then}, @ref{and}, @ref{or_else}.


@c ----------------------------------------------------------------------------


@node AnsiChar
@unnumberedsec AnsiChar
@cindex AnsiChar

@subheading Synopsis

@example
type
  AnsiChar = Char;
@end example

@subheading Description

@samp{AnsiChar} is an 8 bit char type. Currently, it is the same as
@samp{Char}, but this might change in the future, once @samp{wide
chars} (16 bit chars) will be introduced into GPC. Depending on the
platform, @samp{Char} might be either @samp{AnsiChar} or
@samp{WideChar} then.

@subheading Conforming to

@samp{AnsiChar} is a Borland Delphi extension.

@subheading Example

@example
program AnsiCharDemo;
var
  A: AnsiChar;  @{ There is nothing special with `AnsiChar'. @}
  B: Char;
begin
  A := 'A';
  A := B
end.
@end example

@subheading See also

@ref{PAnsiChar}, @ref{Char}.


@c ----------------------------------------------------------------------------


@node Append
@unnumberedsec Append
@cindex Append

@subheading Synopsis

@example
procedure Append (var F: @var{any file}; [FileName: String;]
                                    [BlockSize: Cardinal]);
@end example

@subheading Description

@samp{Append} opens a file for writing. If the file does not
exist, it is created. If it does exist, the file pointer is
positioned after the last element.

Like @samp{Rewrite}, @samp{Reset} and @samp{Extend} do,
@samp{Append} accepts an optional second and third parameter for the
name of the file in the filesystem and, for untyped files, the block
size of the file. (For details, see @ref{Rewrite}.)

@subheading Conforming to

@samp{Append}, including the @samp{BlockSize} parameter, is a
Borland Pascal extension. ISO-10206 Extended Pascal has @ref{Extend}
instead.
The @samp{FileName} parameter is a GNU extension. @c @@@@ Other compilers?

@subheading Example

@example
program AppendDemo;
var
  Sample: Text;
begin
  Assign (Sample, 'sample.txt');
  Rewrite (Sample);
  WriteLn (Sample, 'Hello, World!');  @{ `sample.txt' now has one line @}
  Close (Sample);

  @{ ... @}

  Append (Sample);
  WriteLn (Sample, 'Hello again!');   @{ `sample.txt' now has two lines @}
  Close (Sample)
end.
@end example

@subheading See also

@ref{Assign}, @ref{Reset}, @ref{Rewrite}, @ref{Update},
@ref{Extend}.


@c ----------------------------------------------------------------------------


@node ArcTan
@unnumberedsec ArcTan
@cindex ArcTan

@subheading Synopsis

@example
function ArcTan (x: Real): Real;
@end example
or
@example
function ArcTan (z: Complex): Complex;
@end example

@subheading Description

@samp{ArcTan} returns the (principal value of the) arcus tangent of the
argument. The result is in the range @samp{-Pi / 2 < ArcTan (x) < Pi / 2}
for real arguments.

@subheading Conforming to

The function @samp{ArcTan} is defined in ISO-7185 Pascal;
its application to complex values is defined in ISO-10206 Extended Pascal.

@subheading Example

@example
program ArcTanDemo;
begin
  @{ yields 3.14159 as ArcTan (1) = Pi / 4 @}
  WriteLn (4 * ArcTan (1) : 0 : 5)
end.
@end example

@subheading See also

@ref{Sin}, @ref{Cos}, @ref{Ln}, @ref{Arg}.


@c ----------------------------------------------------------------------------


@node Arg
@unnumberedsec Arg
@cindex Arg

@subheading Synopsis

@example
function Arg (z: Complex): Real;
@end example

@subheading Description

@samp{Arg} returns the complex ``argument'', i.e.@: the angle
(in radian) in the complex plane with respect to the real axis,
of its parameter @samp{z}. The result is in the range of
@samp{-Pi < Arg (z) <= Pi}.

@subheading Conforming to

@samp{Arg} is an ISO-10206 Extended Pascal extension.

@subheading Example

@example
program ArgDemo;
var
  z: Complex;
begin
  z := Cmplx (1, 1);  @{ 1 + i @}
  WriteLn (Arg (z) : 0 : 5)  @{ yields 0.78540, i.e. Pi / 4 @}
end.
@end example

@subheading See also

@ref{ArcTan}, @ref{Ln}, @ref{Polar}.


@c ----------------------------------------------------------------------------


@node array
@unnumberedsec array
@cindex array

@subheading Synopsis

In type definitions:
@example
array [@var{index type}] of @var{element type}
@end example
or
@example
array [@var{index type}, @dots{}, @var{index type}] of @var{element type}
@end example

In parameter list declarations:
@example
array of @var{element type}
@end example

@subheading Description

The reserved word @samp{array} is used to define an array type.

@@@@!!!! arrays in parameter lists

@subheading Conforming to

Array types are defined in ISO 7185 Pascal.

@subheading Example

@example
program ArrayDemo;
type
  IntArray = array [1 .. 20] of Integer;
  WeekDayChars = array [(Mon, Tue, Wed, Thu, Fri, Sat, Sun)] of Char;
  Foo = array [0 .. 9, 'a' .. 'z', (Baz, Glork1, Fred)] of Real;
  TwoDimIntArray = array [1 .. 10] of IntArray;
  @{ is equivalent to: @}
  TwoDimIntArray2 = array [1 .. 10, 1 .. 20] of Integer;

procedure PrintChars (F: array of Char);
var
  i: Integer;
begin
  for i := Low (F) to High (F) do
    WriteLn (F[i])
end;

var
  Waldo: WeekDayChars;

begin
  Waldo := 'HiWorld';
  PrintChars (Waldo)
end.
@end example

@subheading See also

@ref{Array Types}, @ref{High}, @ref{Low}


@c ----------------------------------------------------------------------------


@node as
@unnumberedsec as
@cindex as

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also

@ref{is}, @ref{TypeOf}, @ref{OOP}.


@c ----------------------------------------------------------------------------


@node asm
@unnumberedsec asm
@cindex asm

(Under construction.)

@subheading Synopsis

@subheading Description

See @samp{http://www.gnu-pascal.de/contrib/misc/gpcasm.zip}.

@subheading Conforming to

@samp{asm}, as implemented in GPC, is a GNU extension. It is mostly
compatible to GCC's @samp{asm}, but not compatible to that of
Borland Pascal.

@subheading Example

@subheading See also

@ref{Importing Libraries from Other Languages}, @ref{asmname}


@c ----------------------------------------------------------------------------


@node asmname
@unnumberedsec asmname
@cindex asmname

@subheading Synopsis

@var{procedure/function header}; asmname @var{name};

or

@var{variable declaration}; asmname @var{name};

@subheading Description

The @samp{asmname} directive declares the external name of a
procedure, function or variable. The external name of the routine is
given explicitly as a case-sensitive string constant. This is useful
when interfacing with libraries written in other languages.

With this extension it is possible to access all external functions,
for example the X11 interface functions, and not only those written
in lowercase.

The idea to use @samp{external} for this purpose (to avoid name
space pollution) conflicts with another Borland extension not yet
implemented: In Borland Pascal, the declaration
@example
procedure Foo; external 'MyLib';
@end example
means that the procedure Foo should be imported by name (@samp{Foo})
from a dynamic link library @samp{mylib.dll}.

@samp{asmname} can also be applied to units and module interfaces.
In this case it denotes the @emph{prefix} prepended to the external
name of the initializer of the unit: While it is normally called
@samp{init_Modulename}, it is called
@samp{init_@var{asmname}_Modulename} when @samp{asmname} is given.

This is not of interest under normal circumstances since the
initializers are called automatically. It can help avoiding
conflicts when there are several units of the same name within one
program. Again, this does not happen normally, but e.g., when a
program uses a unit/module that has the same name as one of the
units the RTS consists of: The RTS uses @samp{asmname} for its units
to avoid conflicts.

@c @@@@@@@@
In the future, an @samp{asmname} declaration applied to units,
modules and programs (the latter is recognized syntactically
already, but has no effect yet) will also affect the default
external name of routines and variables which have no @samp{asmname}
declaration themselves. Again, this is mostly useful for libraries
etc., and will not be necessary for normal units, modules and
programs.

@subheading Conforming to

@samp{asmname} is a GNU Pascal extension.

@subheading Example

@example
program AsmnameDemo;

@{ Make two variables aliases of each other by using `asmname'.
  This is not good style. If you must have aliases for any reason,
  `absolute' declaration may be the lesser evil ... @}
var
  Foo: Integer; asmname 'Foo_Bar';
  Bar: Integer; asmname 'Foo_Bar';

@{ A function from the C library @}
function PutS (Str: CString): Integer; asmname 'puts'; external;

var
  Result: Integer;
begin
  Result := PutS ('Hello World!');
  WriteLn ('puts wrote ', Result, ' characters (including a newline).');
  Foo := 42;
  WriteLn ('Foo = ', Foo);
  Bar := 17;
  WriteLn ('Setting Bar to 17.');
  WriteLn ('Now, Foo = ', Foo, '!!!')
end.
@end example

@subheading See also

@ref{C}, @ref{c_language}, @ref{external},
@ref{Importing Libraries from Other Languages}.


@c ----------------------------------------------------------------------------


@node Assign
@unnumberedsec Assign
@cindex Assign

(Under contruction.)

@subheading Synopsis

@example
procedure Assign (var F: @var{any file}; FileName: String);
@end example

@subheading Description

@subheading Conforming to

@samp{Assign} is a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Reset}, @ref{Rewrite}, @ref{Update}, @ref{Extend}, @ref{Append}.


@c ----------------------------------------------------------------------------


@node Assigned
@unnumberedsec Assigned
@cindex Assigned

(Under construction.)

@subheading Synopsis

@example
function Assigned (p: Pointer): Boolean;
@end example
or
@example
function Assigned (p: @var{procedural type}): Boolean;
@end example

@subheading Description

The @samp{Assigned} function returns @samp{True} if the
pointer parameter or the address of the procedural parameter
is not @samp{nil}; it returns @samp{False} if it is @samp{nil}.

@subheading Conforming to

@samp{Assigned} is a Borland Pascal extension.

@subheading Example

@example
program AssignedDemo;
type
  PInt = ^Integer;

procedure TellIfOdd (p: PInt);
begin
  if Assigned (p) and then Odd (p^) then
    WriteLn ('The pointer p points to an odd value.')
end;

var
  foo: Integer;
begin
  TellIfOdd (nil);
  foo := 1;
  TellIfOdd (@@foo);
  foo := 2;
  TellIfOdd (@@foo)
end.
@end example

@subheading See also

@ref{Null}, @ref{nil}, @ref{Pointer}.


@c ----------------------------------------------------------------------------


@node attribute
@unnumberedsec attribute
@cindex attribute

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{attribute} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node begin
@unnumberedsec begin
@cindex begin

@subheading Synopsis

@example
begin
  @var{statement};
  @var{statement};
  @dots{}
  @var{statement}
end;
@end example

@subheading Description

The reserved word @samp{begin} opens a @samp{begin @dots{} end}
statement which joins several @var{statements} to one compound
statement.

@subheading Conforming to

@samp{begin} is defined in ISO 7185 Pascal

@subheading Example

@example
program BeginDemo;
begin
  if True then
    WriteLn ('single statement');
  if True then
    begin                     @{ clamp statement1 ... @}
      WriteLn ('statement1');
      WriteLn ('statement2')
    end                       @{ ... to statement2 @}
end.
@end example

@subheading See also

@ref{begin end Compound Statement}, @ref{end}


@c ----------------------------------------------------------------------------


@node Bind
@unnumberedsec Bind
@cindex Bind

(Under construction.)

@subheading Synopsis

@example
procedure Bind (var F: @var{any file}; B: BindingType);
@end example

@subheading Description

@subheading Conforming to

@samp{Bind} is an ISO-10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node bindable
@unnumberedsec bindable
@cindex bindable

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{bindable} is an ISO-10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Binding
@unnumberedsec Binding
@cindex Binding

(Under construction.)

@subheading Synopsis

@example
function Binding (F: @var{any file}): BindingType;
@end example

@subheading Description

@subheading Conforming to

@samp{Binding} is an ISO-10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node BindingType
@unnumberedsec BindingType
@cindex BindingType

(Under construction.)

@subheading Synopsis

@example
type
  UnixTimeType = LongInt;
  BindingType = @{@@@@packed@} record
    Bound           : Boolean;
    Force           : Boolean;      @{ Can be set to allow binding to
                                      directories or inaccessible files @}
    Extensions_Valid: Boolean;
    Readable        : Boolean;
    Writable        : Boolean;
    Executable      : Boolean;
    Existing        : Boolean;      @{ Binding points to an existing file @}
    Directory       : Boolean;      @{ Binding points to an existing
                                      directory; Existing is False then @}
    Special         : Boolean;      @{ Binding points to an existing
                                      special file (device, pipe, socket,
                                      etc.); `Existing' is False then @}
    SymLink         : Boolean;      @{ Binding points to a symbolic link @}
    AccessTime,                     @{ Time of last access @}
    ModificationTime,                @{ Time of last modification @}
    ChangeTime      : UnixTimeType; @{ Time of last change @}
    User,                           @{ User ID of owner @}
    Group,                          @{ Group ID of owner @}
    Mode,                           @{ Access permissions, cf. ChMod @}
    Device,                         @{ Device the file is on @}
    INode           : Integer;      @{ Unix INode number @}
    TextBinary      : Boolean;      @{ Open a Text file in binary mode @}
    Handle          : Integer;      @{ Can be set to bind a Pascal file to
                                      a given file handle @}
    CloseFlag       : Boolean;      @{ If Handle is used, tell whether to
                                      close it when file is closed @}
    Name            : String (Binding_Name_Length)
  end;
@end example

(@@@@ Currently, in GPC, BindingType is not actually packed.)

The fields @samp{Bound} and @samp{Name} are required by Extended
Pascal.

@code{Binding_Name_Length} is an implementation-defined constant.

@subheading Description

@subheading Conforming to

@samp{BindingType} is an ISO-10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node BitSizeOf
@unnumberedsec BitSizeOf
@cindex BitSizeOf
@cindex bits

@subheading Synopsis

@example
function BitSizeOf (var x): SizeType;
@end example

@subheading Description

Returns the size of a type or variable in bits.

@subheading Conforming to

@samp{BitSizeOf} is a GNU Pascal extension.

@subheading Example

@example
program BitSizeOfDemo;
var
  a: Integer;
  b: array [1 .. 8] of Char;
  c: Integer (12);
  d: packed record
       x: Integer (12);
       y: 0 .. 3
     end;
begin
  WriteLn (BitSizeOf (a));    @{ Size of an `Integer'; usually 32 bits. @}
  WriteLn (BitSizeOf (Integer));  @{ The same. @}
  WriteLn (BitSizeOf (b));    @{ Size of eight `Char's; usually 64 bits. @}
  WriteLn (BitSizeOf (c));    @{ e.g. 16 bits (smallest addressable space). @}
  WriteLn (BitSizeOf (d));    @{ e.g. 16 @}
  WriteLn (BitSizeOf (d.x));  @{ 12 @}
  WriteLn (BitSizeOf (d.y))   @{ 2 @}
end.
@end example

@subheading See also

@ref{SizeOf}, @ref{AlignOf}, @ref{TypeOf}.


@c ----------------------------------------------------------------------------


@node BlockRead
@unnumberedsec BlockRead
@cindex BlockRead

(Under construction.)

@subheading Synopsis

@example
procedure BlockRead (var F: File; var Buffer; Blocks: Integer);
@end example
or
@example
procedure BlockRead (var F: File; var Buffer; Blocks: Integer;
                     var BlocksRead: Integer);
@end example

@subheading Description

@subheading Conforming to

@samp{BlockRead} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node BlockWrite
@unnumberedsec BlockWrite
@cindex BlockWrite

(Under construction.)

@subheading Synopsis

@example
procedure BlockWrite (var F: File; const Buffer; Blocks: Integer);
@end example
or
@example
procedure BlockWrite (var F: File; const Buffer; Blocks: Integer;
                      var BlocksWritten: Integer);
@end example

@subheading Description

@subheading Conforming to

@samp{BlockWrite} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Boolean
@unnumberedsec Boolean
@cindex Boolean

(Under construction.)

@subheading Synopsis

@example
type
  Boolean = (False, True);
@end example
or
@example
type
  Boolean (n)  @{ built-in type class @}
@end example

@subheading Description

@subheading Conforming to

@samp{Boolean} is defined in ISO-7185 Pascal and
supported by all known Pascal variants.

@samp{Boolean (n)} is a GPC extension.

@subheading Example

@example
program BooleanDemo;
var
  a: Boolean;
begin
  a := True;
  WriteLn (a)
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node Break
@unnumberedsec Break
@cindex Break

@subheading Synopsis

@example
Break  @{ simple statement @}
@end example

@subheading Description

With @samp{Break} you can exit the body of the current loop instantly.
It can only be used within a @var{while}, @var{repeat} or a @var{for}
statement.

@subheading Conforming to

@samp{Break} is a Borland Pascal extension.

@subheading Example

@example
program BreakDemo;
var
  Foo: Integer;
begin
  while True do
    begin
      repeat
        WriteLn ('Enter a number less than 100:');
        ReadLn (Foo);
        if Foo < 100 then
          Break;             @{ Exits repeat loop @}
        WriteLn (Foo, ' is not exactly less than 100! Try again ...')
      until False;
      if Foo > 50 then
        Break;              @{ Exits while loop @}
      WriteLn ('The number entered was not greater then 50.')
    end
end.
@end example

@subheading See also

@ref{Loop Control Statements}, @ref{Continue}, @ref{Exit},
@ref{Halt}, @ref{Return}, @ref{goto}.


@c ----------------------------------------------------------------------------


@node Byte
@unnumberedsec Byte
@cindex Byte

@subheading Synopsis

@example
type
  Byte  @{ built-in type @}
@end example

@subheading Description

@samp{Byte} is an unsigned integer type which is one ``unit'' wide.
On most platforms one unit has 8 bits, therefore the type is named
``byte'' and usually has a range of @samp{0..255}. (It is the same
as @ref{ByteCard}.)

@samp{Byte} in GNU Pascal is compatible to @samp{unsigned char}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{Byte} is a Borland Pascal extension. (For something equivalent in
ISO Pascal, see @ref{Subrange Types}.)

@subheading Example

@example
program ByteDemo;
var
  a: Byte;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node ByteBool
@unnumberedsec ByteBool
@cindex ByteBool

(Under construction.)

@subheading Synopsis

@example
type
  ByteBool = Boolean (BitSizeOf (Byte));
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program ByteBoolDemo;
var
  a: ByteBool;
begin
  Byte (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node ByteCard
@unnumberedsec ByteCard
@cindex ByteCard

@subheading Synopsis

@example
type
  ByteCard = Cardinal (BitSizeOf (Byte));
@end example

@subheading Description

@samp{ByteCard} is an unsigned integer type which is one ``unit'' wide.
On most platforms one unit has 8 bits, therefore the type is prefixed
``byte-'' and usually has a range of @samp{0..255}.

@samp{ByteCard} in GNU Pascal is compatible to @samp{unsigned char}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{ByteCard} is a GNU Pascal extension.

@subheading Example

@example
program ByteCardDemo;
var
  a: ByteCard;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node ByteInt
@unnumberedsec ByteInt
@cindex ByteInt

@subheading Synopsis

@example
type
  ByteInt = Integer (BitSizeOf (Byte));
@end example

@subheading Description

@samp{ByteInt} is a signed integer type which is one ``unit'' wide.
On most platforms one unit has 8 bits, therefore the type is prefixed
``byte-'' and usually has a range of @samp{-128..127}.

@samp{ByteInt} in GNU Pascal is compatible to @samp{signed char}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{ByteInt} is a GNU Pascal extension.

@samp{ByteInt} in GNU Pascal corresponds to @ref{ShortInt} in
Borland Pascal.

@subheading Example

@example
program ByteIntDemo;
var
  a: ByteInt;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node C
@unnumberedsec C
@cindex C

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also

@ref{Importing Libraries from Other Languages}, @ref{c_language}


@c ----------------------------------------------------------------------------


@node Card
@unnumberedsec Card
@cindex Card

@subheading Synopsis

@example
function Card (S: @var{any set}): Integer;
@end example

@subheading Description

The function @samp{Card (S)} returns the number of elements in the set
@samp{S}.

@subheading Conforming to

@samp{Card} is an ISO 10206 Extended Pascal extension.

@subheading Example

@example
program CardDemo;
var
  Foo: set of 1 .. 100;
begin
  Foo := [1, 2, 3, 5, 1, 1, 1, 2, 2, 2, 3, 3, 5, 5];  @{ four elements @}
  WriteLn ('foo consists of ', Card (Foo), ' elements')
end.
@end example

@subheading See also

@ref{set}


@c ----------------------------------------------------------------------------


@node Cardinal
@unnumberedsec Cardinal
@cindex Cardinal

@subheading Synopsis

@example
type
  Cardinal  @{ built-in type @}
@end example
or
@example
type
  Cardinal (n)  @{ built-in type class @}
@end example

@subheading Description

@samp{Cardinal} is the ``natural'' unsigned integer type in GNU Pascal.
On most platforms it is 32 bits wide and thus has a range of
@samp{0..4294967295}. Use it whenever you need a general-purpose
unsigned integer type and don't need to care about compatibility
to other Pascal dialects.

As an extension, GPC allows to use @samp{Cardinal} as a pseudo-schema
to produce types with a specified size in bits; for example

@example
type
  Card16 = Cardinal (16);
@end example

@noindent defines an unsigned integer type with 16 bits. The same
mechanism works for @samp{Integer} and @samp{Word}, too.

@samp{Cardinal} in GNU Pascal is compatible to @samp{unsigned int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{Cardinal} is not defined in ISO Pascal, but several Pascal
compilers support it as an extension. In Borland Delphi, for
instance, it is an unsigned 16-bit in version 1.0, an unsigned
31-bit integer from version 2.0 on, and an unsigned 32-bit
integer from version 4.0 on.

@subheading Example

@example
program CardinalDemo;
var
  a: Cardinal;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node case
@unnumberedsec case
@cindex case

@subheading Synopsis

@example
case @var{expression} of
  @var{selector}: @var{statement};
  @dots{}
  @var{selector}: @var{statement};
end;
@end example
or, with alternative statement sequence:
@example
case @var{expression} of
  @var{selector}: @var{statement};
  @dots{}
  @var{selector}: @var{statement};
otherwise                   @{ ``else'' instead of ``otherwise'' is allowed @}
  @var{statement};
  @dots{}
  @var{statement};
end;
@end example
or, as part of the invariant @code{record} type definition:
@example
foo = record
  @var{field declarations}
case bar: @var{variant type} of
  @var{selector}: (@var{field declarations});
  @var{selector}: (@var{field declarations});
  @dots{}
end;
@end example
or, without a variant selector field,
@example
foo = record
  @var{field declarations}
case @var{variant type} of
  @var{selector}: (@var{field declarations});
  @var{selector}: (@var{field declarations});
  @dots{}
end;
@end example

@subheading Description

@samp{case} opens a case statement. For further description see
@ref{case Statement}.

For @samp{case} in a variant record type definition, see @ref{Record Types}.

@subheading Conforming to

The @samp{case} statement is defined in ISO-7185 Pascal and
supported by all known Pascal variants.

According to ISO 7185 Pascal, the selector type must be a named type.
GNU Pascal, UCSD and Borland Pascal also allow a subrange here.

The alternative statement execution with @samp{otherwise} it is an
Extended Pascal extension; with @samp{else} it is a Borland Pascal
extension. In GNU Pascal, both are allowed.

@subheading Example

@example
program CaseDemo;
var
  Foo: String (10);
  Bar: Integer;
begin
  WriteLn ('Enter up to ten arbitrary characters:');
  ReadLn (Foo);
  for Bar := 1 to Length (Foo) do
    begin
      Write (Foo[Bar], ' is ');
      case Foo[Bar] of
        'A' .. 'Z', 'a' .. 'z':
          WriteLn ('an English letter');
        '0' .. '9':
          WriteLn ('a number');
      otherwise
        WriteLn ('an unrecognized character')
      end
    end
end.
@end example

@subheading See also

@ref{if Statement}, @ref{Record Types}


@c ----------------------------------------------------------------------------


@node Char
@unnumberedsec Char
@cindex Char

(Under construction.)

@subheading Synopsis

@example
type
  Char  @{ built-in type @}
@end example

@subheading Description

@subheading Conforming to

@samp{Char} is defined in ISO-7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@example
program CharDemo;
var
  a: Char;
begin
  a := 'x';
  WriteLn (a)
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node ChDir
@unnumberedsec ChDir
@cindex ChDir

@subheading Synopsis

@example
procedure ChDir (Directory: String);
@end example

@subheading Description

@samp{ChDir} changes the current directory to @var{Directory}, if its
argument is a valid parameter to the related operating system's function.
Otherwise, a runtime error is caused.

@subheading Conforming to

@samp{ChDir} is a Borland Pascal extension.

@subheading Example

@example
program ChDirDemo;
var
  Foo: String (127);
begin
  WriteLn ('Enter directory name to change to:');
  ReadLn (Foo);
  @{$I-@}  @{ Don't abort the program on error @}
  ChDir (Foo);
  if IOResult <> 0 then
    WriteLn ('Cannot change to directory `', foo, '''.')
  else
    WriteLn ('Okay.')
end.
@end example

@subheading See also

@ref{MkDir}, @ref{RmDir}


@c ----------------------------------------------------------------------------


@node Chr
@unnumberedsec Chr
@cindex Chr

@subheading Synopsis

@example
function Chr (AsciiCode: Integer): Char;
@end example

@subheading Description

@samp{Chr} returns a character whose ASCII code corresponds to the value
given by @samp{AsciiCode}.

@subheading Conforming to

@samp{Chr} is defined in ISO-7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@example
program ChrDemo;
var
  x: Integer;
begin
  for x := 32 to 122 do
    Write (Chr (x))
end.
@end example

@subheading See also

@ref{Ord}


@c ----------------------------------------------------------------------------


@node c_language
@unnumberedsec c_language
@cindex c_language

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also

@ref{Importing Libraries from Other Languages}, @ref{C}


@c ----------------------------------------------------------------------------


@node class
@unnumberedsec class
@cindex class

Not yet implemented.

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Close
@unnumberedsec Close
@cindex Close

(Under construction.)

@subheading Synopsis

@example
procedure Close (var F: @var{any file});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Cmplx
@unnumberedsec Cmplx
@cindex Cmplx

@subheading Synopsis

@example
function Cmplx (RealPart, ImaginaryPart: Real): Complex;
@end example

@subheading Description

@samp{Cmplx} makes a complex number from @samp{RealPart} and
@samp{ImaginaryPart}.

@subheading Conforming to

@samp{Cmplx} is an ISO-10206 Extended Pascal extension.

@subheading Example

@example
program CmplxDemo;
var
  z: Complex;
  x, y: Real;
begin
  z := Cmplx (x, y)  @{ z := x + iy @}
end.
@end example

@subheading See also

@ref{Re}, @ref{Im}, @ref{Polar}, @ref{Arg}


@c ----------------------------------------------------------------------------


@node Comp
@unnumberedsec Comp
@cindex Comp

@subheading Synopsis

@example
type
  Comp = LongInt;
@end example

@subheading Description

@samp{Comp} is a signed integer type which is longer than
@samp{Integer}.  On most platforms it is 64 bits wide and thus has
a range of @samp{-9223372036854775808..9223372036854775807}.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{Comp} is a Borland Pascal extension.

In some contexts, Borland Pascal treats @samp{Comp} as a ``real''
type -- this behaviour is not supported by GPC.

@subheading Example

@example
program CompDemo;
var
  a: Comp;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node Complex
@unnumberedsec Complex
@cindex Complex

(Under construction.)

@subheading Synopsis

@example
type
  Internal_Complex = record @{ not visible @}
    RealPart, ImaginaryPart: Real
  end;
  Complex = restricted Internal_Complex;
@end example

@subheading Description

@subheading Conforming to

@samp{Complex} is an ISO-10206 Extended Pascal extension.

@subheading Example

@example
program ComplexDemo;
var
  a: Complex;
begin
  a := Cmplx (42, 3);
  WriteLn (Re (a), ' + ', Im (a), ' i')
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node Concat
@unnumberedsec Concat
@cindex Concat

(Under construction.)

@subheading Synopsis

@example
function Concat (S1, S2: String): String;
@end example
or
@example
function Concat (S1, S2, S3: String): String;
@end example
or
@example
@dots{}
@end example

@subheading Description

@subheading Conforming to

@samp{Concat} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Conjugate
@unnumberedsec Conjugate
@cindex Conjugate

@subheading Synopsis

@example
function Conjugate (z: Complex): Complex;
@end example

@subheading Description

@samp{Conjugate} computes the complex conjugate of the complex number @samp{z}

@subheading Conforming to

@samp{Conjugate} is an ISO-10206 Extended Pascal extension.

@subheading Example

@example
program ConjugateDemo;
var
  z: Complex;
begin
  z := Cmplx (2, 3);  @{ z is 2 + i * 3 @}
  WriteLn ('z = ', Re (z) : 0 : 5, ' + i * ', Im (z) : 0 : 5);
  z := Conjugate (z);  @{ z conjugate is 2 - i * 3 @}
  WriteLn ('z conjugate = ', Re (z) : 0 : 5,' + i * ', Im (z) : 0 : 5)
end.
@end example

@subheading See also

@ref{Cmplx}, @ref{Re}, @ref{Im}, @ref{Abs}


@c ----------------------------------------------------------------------------


@node const
@unnumberedsec const
@cindex const

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{const} is defined in ISO-7185 Pascal and
supported by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node constructor
@unnumberedsec constructor
@cindex constructor

(Under construction.)
@c ;-)))

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{constructor} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Continue
@unnumberedsec Continue
@cindex Continue

@subheading Synopsis

@example
Continue  @{ simple statement @}
@end example

@subheading Description

@samp{Continue} goes on with loop iteration by jumping to the end of the
current loop body. Note: @samp{Continue} can only stand within a @var{while},
@var{repeat} or a @var{for} statement.

@subheading Conforming to

@samp{Continue} is a Borland Pascal extension.

@subheading Example

@example
program ContinueDemo;
var
  Foo, Bar: Integer;
begin
  WriteLn ('Enter three numbers:');
  for Bar := 1 to 3 do
    begin
      ReadLn (Foo);
      if Foo < 5 then
        Continue;
      WriteLn ('Your number was greater then 5.')
    end
end.
@end example

@subheading See also

@ref{Loop Control Statements}, @ref{Break}, @ref{Exit}, @ref{Halt},
@ref{Return}, @ref{goto}.


@c ----------------------------------------------------------------------------


@node Copy
@unnumberedsec Copy
@cindex Copy

@subheading Synopsis

@example
function Copy (S: String; FirstChar, Count: Integer): String;
@end example
or
@example
function Copy (S: String; FirstChar: Integer): String;
@end example

@subheading Description

@samp{Copy} returns a sub-string of @samp{S} starting with the
character at position @var{FirstChar}. If @var{Count} is given, such
many characters will be copied into the sub-string. If @var{Count} is
omitted, the sub-string will will range to the end of @var{S}.

If @samp{Count} is too large for the sub-string to fit in @var{S}, the
result will be truncated at the end of @var{S}. If @samp{FirstChar}
exceeds the length of @var{S}, the empty string will be returned. (For
a function which does not truncate but triggers a runtime error instead,
see @ref{SubStr}.)

Please note that GPC's strings may be longer than 255 characters. If
you want to isolate the second half of a string @var{S} starting with
the third character, use @samp{Copy (S, 3)} instead of
@samp{Copy (S, 3, 255)}.

@subheading Conforming to

@samp{Copy} is a UCSD Pascal extension. The possibility to omit the
third parameter is a GNU Pascal extension.

@subheading Example

@example
program CopyDemo;
var
  S: String (42);
begin
  S := 'Hello';
  WriteLn (Copy (S, 2, 3));  @{ yields `ell' @}
  WriteLn (Copy (S, 3));     @{ yields `llo' @}
  WriteLn (Copy (S, 4, 7));  @{ yields `lo' @}
  WriteLn (Copy (S, 42))     @{ yields the empty string @}
end.
@end example

@subheading See also

@ref{SubStr}, @ref{String Slice Access}.


@c ----------------------------------------------------------------------------


@node Cos
@unnumberedsec Cos
@cindex Cos

@subheading Synopsis

@example
function Cos (x: Real): Real;
@end example
or
@example
function Cos (z: Complex): Complex;
@end example

@subheading Description

@samp{Cos} returns the cosine of the argument.
The result is in the range @samp{-1 < Cos (x) < 1} for real arguments.

@subheading Conforming to

The function @samp{Cos} is defined in ISO-7185 Pascal;
its application to complex values is defined in ISO-10206 Extended Pascal.

@subheading Example

@example
program CosDemo;
begin
  WriteLn (Cos (SqRt (2) / 2) : 0 : 5)
    @{ yields 0.5 since Cos (SqRt (2) / 2) = 0.5 @}
end.
@end example

@subheading See also

@ref{ArcTan}, @ref{Sin}, @ref{Ln}, @ref{Arg}.


@c ----------------------------------------------------------------------------


@node CString
@unnumberedsec CString
@cindex CString

(Under construction.)

@subheading Synopsis

@example
type
  CString = ^Char;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program CStringDemo;
var
  s: CString;
begin
  s := 'Hello, world!';
  @{$X+@}
  WriteLn (s)
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node CString2String
@unnumberedsec CString2String
@cindex CString2String

(Under construction.)

@subheading Synopsis

@example
function CString2String (S: CString): String;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node CStringCopyString
@unnumberedsec CStringCopyString
@cindex CStringCopyString

(Under construction.)

@subheading Synopsis

@example
function CStringCopyString (Dest: CString; const Source: String): CString;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Date
@unnumberedsec Date
@cindex Date

(Under construction.)

@subheading Synopsis

@example
function Date (T: TimeStamp): packed array [1 .. @var{Date length}] of Char;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Dec
@unnumberedsec Dec
@cindex Dec

@subheading Synopsis

For ordinal types:
@example
procedure Dec (var x: @var{ordinal type});
@end example
or
@example
procedure Dec (var x: @var{ordinal type}; Amount: Integer);
@end example

For pointer types:
@example
procedure Dec (var p: @var{any pointer type});
@end example
or
@example
procedure Dec (var p: @var{any pointer type}; Amount: Integer);
@end example

@subheading Description

For ordinal types, @samp{Dec} decreases the value of @samp{x} by one or
by @samp{amount} if specified.

If the argument @samp{p} is pointing to a specified type (typed pointer),
@samp{Dec} decreases the address of @samp{p} by the size of the type @samp{p}
is pointing to or by @samp{amount} times that size respectively. If @samp{p}
is an untyped pointer (i.e. @samp{p} is of type @ref{Pointer}), @samp{p} is
decreased by one, otherwise by @samp{amount} if specified.

@subheading Conforming to

@samp{Dec} is a Borland Pascal extension. The combination of the second
argument with application to pointers is a GNU extension.

@subheading Example

@example
program DecDemo;
var
  x: Integer;
  y: array [1 .. 5] of Integer;
  p: ^Integer;
begin
  x := 9;
  Dec (x, 10);     @{ yields -1 @}
  @{$X+@}            @{ Turn on extended systax @}
  p := @@y[5];      @{ p points to y[5] @}
  Dec (p, 3)       @{ p points to y[2] @}
end.
@end example

@subheading See also

@ref{Inc}, @ref{Pred}, @ref{Succ}, @ref{Pointer Arithmetics}.


@c ----------------------------------------------------------------------------


@node DefineSize
@unnumberedsec DefineSize
@cindex DefineSize

(Under construction.)

@subheading Synopsis

@example
procedure DefineSize (var F: @var{any file}; NewSize: Integer);
@end example

@subheading Description

@subheading Conforming to

@samp{DefineSize} is an ISO-10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Delete
@unnumberedsec Delete
@cindex Delete

(Under construction.)

@subheading Synopsis

@example
procedure Delete (var S: String; FirstChar, Count: Integer);
@end example
or
@example
procedure Delete (var S: String; FirstChar: Integer);
@end example

@subheading Description

@subheading Conforming to

@samp{Delete} is a UCSD Pascal extension. The possibility to omit
the third parameter is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node destructor
@unnumberedsec destructor
@cindex destructor

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{destructor} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Dispose
@unnumberedsec Dispose
@cindex Dispose

(Under construction.)

@subheading Synopsis

@example
Dispose (PointerVar: Pointer);
@end example
or
@example
Dispose (PointerVar: Pointer; @var{tag field values});
@end example
or
@example
Dispose (ObjectPointerVar: Pointer; @var{destructor call});
@end example

@subheading Description

@subheading Conforming to

@samp{Dispose} is defined in ISO-7185 Pascal and
supported by most known Pascal variants, but not by UCSD Pascal.
Its use for objects is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node div
@unnumberedsec div
@cindex div

(Under construction.)

@subheading Synopsis

@example
operator div (p, q: Integer) = r: Integer;
@end example

@subheading Description

@subheading Conforming to

@samp{div} is defined in ISO-7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node do
@unnumberedsec do
@cindex do

@subheading Synopsis

@example
for ... do
  @var{statement}
@end example
or
@example
while ... do
  @var{statement}
@end example
or
@example
with ... do
  @var{statement}
@end example
or
@example
to begin do
  @var{statement}
@end example
or
@example
to end do
  @var{statement}
@end example

@subheading Description

The @samp{do} reserved word is used in combination with other Pascal
keywords in many ways. For description and examples see the relevant
reference sections: @samp{for}, @samp{while}, @samp{with},
@samp{to begin}, @samp{to end}.

@subheading Conforming to

@samp{do} is defined in ISO-7185 Pascal and supported by all
known Pascal variants.

@subheading Example

See references.

@subheading See also

@ref{for}, @ref{while}, @ref{with}, @ref{to begin do}, @ref{to end do}.


@c ----------------------------------------------------------------------------


@node Double
@unnumberedsec Double
@cindex Double

(Under construction.)

@subheading Synopsis

@example
type
  Double = Real;
@end example

@subheading Description

@samp{Double} is a synonym for the @samp{Real} data type and
supported for compatibility with other compilers.

@subheading Conforming to

@samp{Double} is a Borland Pascal extension.

@subheading Example

@example
program DoubleDemo;
var
  A: Double;  @{ There is nothing special with `Double'. @}
  B: Real;
begin
  A := Pi;
  A := B
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node downto
@unnumberedsec downto
@cindex downto

@subheading Synopsis

@example
for @var{variable} := @var{value1} downto @var{value2} do
  @var{statement}
@end example

@subheading Description

The @samp{downto} reserved word is used in combination with
@samp{for} to build a @samp{for} loop.

@subheading Conforming to

@samp{downto} is defined in ISO-7185 Pascal and
supported by all known Pascal variants.

@subheading Example

See @ref{for}.

@subheading See also

@ref{for}.


@c ----------------------------------------------------------------------------


@node else
@unnumberedsec else
@cindex else

@subheading Synopsis

As part of the @code{if} @dots{} @code{then} @dots{} @code{else} statement:
@example
if @var{Boolean expression} then
  @var{statement1}
else
  @var{statement2}
@end example
or, as part of the @code{case} @dots{} @code{else} statement:
@example
case @var{expression} of
  @var{selector}: @var{statement};
  @dots{}
  @var{selector}: @var{statement}
else
  @var{statement};
  @dots{}
  @var{statement}
end
@end example

@subheading Description

@samp{else} is part of the @samp{if @dots{} then @dots{} else} statement
which provides a possibility to execute statements alternatively.  In
the @code{case} statement, @samp{else} starts a series of statements
which is executed if no selector fit in @var{expression}. In this case,
@samp{else} is a synonym for @code{otherwise}.

@subheading Conforming to

@samp{else} in @samp{if} statements is defined in ISO-7185
Pascal and supported by all known Pascal variants. @samp{else} in
@samp{case} statements is a Borland Pascal extension; ISO-10206 Extended
Pascal has @samp{otherwise} instead.

@subheading Example

@example
program ElseDemo;
var
  i: Integer;
begin
  Write ('Enter a number: ');
  ReadLn (i);
  if i > 42 then
    WriteLn ('The number is greater than 42')
  else
    WriteLn ('The number is not greater than 42')
end.
@end example

@subheading See also

@ref{if}, @ref{case}, @ref{otherwise}.


@c ----------------------------------------------------------------------------


@node Empty
@unnumberedsec Empty
@cindex Empty

(Under construction.)

@subheading Synopsis

@example
function Empty (var F: @var{any file}): Boolean;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node end
@unnumberedsec end
@cindex end

@subheading Synopsis

@example
begin
  @var{statement};
  @var{statement};
  @dots{}
  @var{statement}
end
@end example

@subheading Description

The reserved word @samp{end} closes a @samp{begin} @dots{} @samp{end};
statement which joins several @var{statements} together into one compound
statement.

@@@@ end of a <case> statement
@@@@ end of a record or object declaration
@@@@ part of a <to end do> module destructor

@subheading Conforming to

@samp{end} is defined in ISO-7185 Pascal
and supported by all Pascal variants.

@subheading Example

@example
program EndDemo;
begin
  if True then
    WriteLn ('single statement');
  if True then
    begin                     @{ clamp statement1 ... @}
      WriteLn ('statement1');
      WriteLn ('statement2')
    end                       @{ ... to statement2 @}
end.
@end example

@subheading See also

@ref{begin end Compound Statement}, @ref{begin}


@c ----------------------------------------------------------------------------


@node EOF
@unnumberedsec EOF
@cindex EOF

(Under construction.)

@subheading Synopsis

@example
function EOF (var F: @var{any file}): Boolean;
@end example
or
@example
function EOF: Boolean;
@end example

@subheading Description

@subheading Conforming to

@samp{EOF} is defined in ISO-7185 Pascal
and supported by all Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node EOLn
@unnumberedsec EOLn
@cindex EOLn

(Under construction.)

@subheading Synopsis

@example
function EOLn (var F: @var{any file}): Boolean;
@end example
or
@example
function EOLn: Boolean;
@end example

@subheading Description

@subheading Conforming to

@samp{EOLn} is defined in ISO-7185 Pascal
and supported by all Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node EpsReal
@unnumberedsec EpsReal
@cindex EpsReal

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{EpsReal} is an ISO-10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node EQ
@unnumberedsec EQ
@cindex EQ

(Under construction.)

@subheading Synopsis

@example
function EQ (S1, S2: String): Boolean;
@end example

@subheading Description

@subheading Conforming to

@samp{EQ} is an ISO-10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Erase
@unnumberedsec Erase
@cindex Erase

(Under construction.)

@subheading Synopsis

@example
procedure Erase (var F: @var{any file});
@end example

@subheading Description

@subheading Conforming to

@samp{Erase} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Exclude
@unnumberedsec Exclude
@cindex Exclude

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Exit
@unnumberedsec Exit
@cindex Exit

@subheading Synopsis

@example
procedure Exit;
@end example

@subheading Description

@samp{Exit} leaves the currently executed procedure or function.
Note: If @samp{Exit} is called within the main program, it will be
terminated instantly.

@subheading Conforming to

@samp{Exit} is a UCSD Pascal extension. GNU Pascal does not support all
uses of @samp{Exit} but only those defined in Borland Pascal.

@subheading Example

@example
program ExitDemo;

procedure Foo (Bar: Integer);
var
  Baz, Fac: Integer;
begin
  if Bar < 1 then
    Exit;                  @{ Exit foo @}
  Fac := 1;
  for Baz := 1 to Bar do
    begin
      Fac := Fac * Baz;
      if Fac >= Bar then       @{ Exit foo @}
        Exit;
      WriteLn (Bar,' is greater then ', baz, '!, which is equal to ', Fac)
  end
end;

begin
  Foo (-1);
  Foo (789);
  Exit;                  @{ Terminates program @}
  Foo (987654321)        @{ This is not executed any more @}
end.
@end example

@subheading See also

@ref{Break}, @ref{Continue}, @ref{Halt}


@c ----------------------------------------------------------------------------


@node Exp
@unnumberedsec Exp
@cindex Exp

@subheading Synopsis

@example
function Exp (x: Real): Real;
@end example
or
@example
function Exp (z: Complex): Complex;
@end example

@subheading Description

The exponential function @samp{Exp} computes the value of e to the power
of x, where the Euler number e = Exp (1) is the base of the natural
logarithm.

@subheading Conforming to

The function @samp{Exp} is defined in ISO-7185 Pascal;
its application to complex values is defined in ISO-10206 Extended Pascal.

@subheading Example

@example
program ExpDemo;
var
  z: Complex;
begin
  z := Cmplx (1, - 2 * Pi);  @{ z = 1 - 2 pi i @}
  z := Exp (z);  @{ yields e = Exp (1), since Exp ix = Cos x + i Sin x @}
  WriteLn (Ln (Re (z)) : 0 : 5)  @{ prints 1 = Ln (Exp (1)) @}
end.
@end example

@subheading See also

@ref{Ln}


@c ----------------------------------------------------------------------------


@node export
@unnumberedsec export
@cindex export

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{export} is an ISO-10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node exports
@unnumberedsec exports
@cindex exports

Not yet implemented.

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{exports} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Extend
@unnumberedsec Extend
@cindex Extend

(Under construction.)

@subheading Synopsis

@example
procedure Extend (var F: @var{any file}; [FileName: String;]
                                    [BlockSize: Cardinal]);
@end example

@subheading Description

@samp{Extend} opens a file for writing. If the file does not
exist, it is created. If it does exist, the file pointer is
positioned after the last element.

Like @samp{Rewrite}, @samp{Reset} and @samp{Append} do,
@samp{Extend} accepts an optional second and third parameter for the
name of the file in the filesystem and, for untyped files, the block
size of the file. (For details, see @ref{Rewrite}.)

@subheading Conforming to

@samp{Extend} is an ISO-10206 Extended extension. Borland Pascal
Pascal has @ref{Append} instead.
The @samp{BlockSize} parameter is a Borland Pascal extension.
The @samp{FileName} parameter is a GNU extension. @c @@@@ Other compilers?

@subheading Example

@example
program ExtendDemo;
var
  Sample: Text;
begin
  Assign (Sample, 'sample.txt');
  Rewrite (Sample);
  WriteLn (Sample, 'Hello, World!');  @{ `sample.txt' now has one line @}
  Close (Sample);

  @{ ... @}

  Extend (Sample);
  WriteLn (Sample, 'Hello again!');   @{ `sample.txt' now has two lines @}
  Close (Sample)
end.
@end example

@subheading See also

@ref{Assign}, @ref{Reset}, @ref{Rewrite}, @ref{Update},
@ref{Append}.


@c ----------------------------------------------------------------------------


@node Extended
@unnumberedsec Extended
@cindex Extended

(Under construction.)

@subheading Synopsis

@example
type
  Extended = LongReal;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program ExtendedDemo;
var
  a: Extended;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node extern
@unnumberedsec extern
@cindex extern

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node external
@unnumberedsec external
@cindex external

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Fail
@unnumberedsec Fail
@cindex Fail

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node False
@unnumberedsec False
@cindex False

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node far
@unnumberedsec far
@cindex far

@subheading Synopsis

@subheading Description

The @samp{far} directive can be appended to a procedure or function
heading but is ignored by GPC. It is there for Borland compatibility,
only. (Since the GNU compilers provide a flat memory model, the
distinction between @samp{near} and @samp{far} pointers is void.)

@subheading Conforming to

@samp{far} is a Borland Pascal extension.

@subheading Example

@example
program FarDemo;

var
  p: procedure;

@{$W-@}  @{ Don't warn about the uselessness of `far' @}

procedure Foo; far;  @{ `far' has no effect in GPC @}
begin
  WriteLn ('Foo')
end;

begin
  p := Foo;  @{ Would also work without `far' in GPC. @}
  p
end.
@end example

@subheading See also

@ref{near}.


@c ----------------------------------------------------------------------------


@node file
@unnumberedsec file
@cindex file

(Under construction.)

@subheading Synopsis

In type definitions:
@example
File of @var{Type}
@end example
or
@example
File
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node FileMode
@unnumberedsec FileMode
@cindex FileMode

(Under construction.)

@subheading Synopsis

@example
var
  FileMode: Integer;
@end example

@subheading Description

@subheading Conforming to

@samp{FileMode} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node FilePos
@unnumberedsec FilePos
@cindex FilePos

(Under construction.)

@subheading Synopsis

@example
function FilePos (var F: @var{any file}): Integer;
@end example

@subheading Description

@subheading Conforming to

@samp{FilePos} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node FileSize
@unnumberedsec FileSize
@cindex FileSize

(Under construction.)

@subheading Synopsis

@example
function FileSize (var F: @var{any file}): Integer;
@end example

@subheading Description

@subheading Conforming to

@samp{FileSize} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node FillChar
@unnumberedsec FillChar
@cindex FillChar

(Under construction.)

@subheading Synopsis

@example
procedure FillChar (var Dest; Count: SizeType; Val: Char);
@end example
or
@example
procedure FillChar (var Dest; Count: SizeType; Val: Byte);
@end example

@subheading Description

@subheading Conforming to

@samp{FillChar} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Finalize
@unnumberedsec Finalize
@cindex Finalize

(Under construction.)

@subheading Synopsis

@example
procedure Finalize (var Aynthing);
@end example

@subheading Description

@samp{Finalize} does all necessary clean-ups for the parameter. This
is normally done automatically when a variable goes out of scope, so
you need to call @samp{Finalize} only in special situations, e.g.
when you deallocate a dynamic variable with @samp{FreeMem} rather
than @samp{Dispose}.

@subheading Conforming to

@samp{Finalize} is a Delphi extension.

@subheading Example

@subheading See also

@ref{Initialize}, @ref{Dispose}, @ref{FreeMem}.


@c ----------------------------------------------------------------------------


@node Flush
@unnumberedsec Flush
@cindex Flush

(Under construction.)

@subheading Synopsis

@example
procedure Flush (var F: @var{any file});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node for
@unnumberedsec for
@cindex for

@subheading Synopsis

For ordinal index variables:
@example
for @var{ordinal variable} := @var{initial value} to @var{final value} do
  @var{statement}
@end example
or
@example
for @var{ordinal variable} := @var{initial value} downto @var{final value} do
  @var{statement}
@end example

For sets:
@example
for @var{set element type variable} in @var{some set} do
  @var{statement}
@end example

For pointer index variables:
@example
for @var{pointer variable} := @var{initial address} to @var{final address} do
  @var{statement}
@end example
or
@example
for @var{pointer variable} := @var{initial address} downto @var{final address} do
  @var{statement}
@end example

@@@@ Set member iteration

@subheading Description

The @samp{for} statement is a count loop. For further information
see @ref{for Statement}.

@subheading Conforming to

@samp{for} is defined in ISO-7185 Pascal and supported by all
Pascal variants. Iteration of Pointers is a Borland Pascal extension.
Set member iteration is an ISO-10206 Extended Pascal extension.

@subheading Example

@example
program ForDemo;
var
  CharSet: set of Char;
  c: Char;
  n: Integer;
  Fac: array [0 .. 10] of Integer;
  PInt: ^Integer;
begin
   CharSet := ['g', 'p', 'c'];
   for c in CharSet do
     WriteLn (c);       @{ prints c g p in three lines @}
   Fac[0] := 1;
   for n := 1 to 10 do  @{ computes the factorial of n for n = 0 .. 10 @}
     Fac[n] := Fac[n - 1] * n;
   @{$X+@}
   @{ prints n! for n = 0 .. 10 @}
   for PInt := @@Fac[0] to @@Fac[10] do
     WriteLn (PInt - @@Fac[0], '! = ', PInt^)
end.
@end example

@subheading See also

@ref{Set Types}, @ref{Pointer Arithmetics}


@c ----------------------------------------------------------------------------


@node FormatString
@unnumberedsec FormatString
@cindex FormatString

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node forward
@unnumberedsec forward
@cindex forward

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Frac
@unnumberedsec Frac
@cindex Frac

(Under construction.)

@subheading Synopsis

@example
function Frac (x: Real): Real;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node FrameAddress
@unnumberedsec FrameAddress
@cindex FrameAddress

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node FreeMem
@unnumberedsec FreeMem
@cindex FreeMem

@subheading Synopsis

@example
procedure FreeMem (var p: Pointer; Size: Cardinal);
@end example
or
@example
procedure FreeMem (var p: Pointer);
@end example

@subheading Description

Releases a chunk of memory previously allocated using @samp{GetMem}.
The parameter @var{Size} is optional, and its value is ignored.

Since Extended Pascal's schemata provide a cleaner way to implement dynamical
arrays and such, we recommend using @samp{GetMem} and @samp{FreeMem} only for
low-level applications or for interfacing with other languages.

@subheading Conforming to

@samp{FreeMem} is a Borland Pascal extension. @samp{FreeMem}
with only one parameter is a GNU Pascal extension.

@subheading Example

@xref{GetMem}.

@subheading See also

@ref{GetMem}, @ref{Schema Types}, @ref{Dispose}, @ref{Mark}, @ref{Release}.


@c ----------------------------------------------------------------------------


@node function
@unnumberedsec function
@cindex function

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node GE
@unnumberedsec GE
@cindex GE

(Under construction.)

@subheading Synopsis

@example
function GE (S1, S2: String): Boolean;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Get
@unnumberedsec Get
@cindex Get

(Under construction.)

@subheading Synopsis

@example
procedure Get (var F: @var{typed file});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node GetMem
@unnumberedsec GetMem
@cindex GetMem

@subheading Synopsis

@example
procedure GetMem (var p: Pointeger; Size: Cardinal);
@end example
or
@example
function GetMem (Size: Cardinal): Pointer;
@end example

@subheading Description

Allocates dynamical storage on the heap and returns a pointer to it in
@samp{p} or as the function result.

Since Extended Pascal's schemata provide a cleaner way to implement dynamical
arrays and such, we recommend using @samp{GetMem} and @samp{FreeMem} only for
low-level applications.

@subheading Conforming to

@samp{GetMem} is a Borland Pascal extension.  The use of
@samp{GetMem} as a function is a GNU Pascal extension.

@subheading Example

The Borland-comatibility unit @samp{Graph} from the @file{BPcompat} package
supports a @samp{GetImage} and a @samp{PutImage} procedure which need a
variable of size @samp{ImageSize} as a buffer.  Since these are ``black box''
routines, the buffer can't reasonably be a schema providing a dynamical array.
Instead, we have to use @samp{GetMem} and @samp{FreeMem} for dynamical memory
allocation.

@example
program GetMemDemo;
var
  Buffer: Pointer;
  Size: Cardinal;
begin
  Size := Random (10000); @{ the size can be determined at run time @}
  Buffer := GetMem (Size);  @{ or: GetMem (Buffer, Size); @}
  @{ Do something with Buffer @}
  FreeMem (Buffer)  @{ or: FreeMem (Buffer, Size) @}
end.
@end example

@subheading See also

@ref{FreeMem}, @ref{New}, @ref{Schema Types}.


@c ----------------------------------------------------------------------------


@node GetTimeStamp
@unnumberedsec GetTimeStamp
@cindex GetTimeStamp

(Under construction.)

@subheading Synopsis

@example
procedure GetTimeStamp (var T: TimeStamp);
@end example

@subheading Description

@subheading Conforming to

@samp{GetTimeStamp} is an ISO-10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node goto
@unnumberedsec goto
@cindex goto

(Under construction.)

@subheading Synopsis

@example
goto @var{label}
@end example

@subheading Description

The @samp{goto} statement transfers control to statement with the label
@samp{label}.

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node GT
@unnumberedsec GT
@cindex GT

(Under construction.)

@subheading Synopsis

@example
function GT (S1, S2: String): Boolean;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Halt
@unnumberedsec Halt
@cindex Halt

@subheading Synopsis

@example
Halt;
@end example
or
@example
Halt (ExitCode: Integer);
@end example

@subheading Description

@samp{Halt} terminates the program with exitcode 0. If @samp{ExitCode},
is specified, it is returned by @samp{Halt} on exit.

@subheading Conforming to

@samp{Halt} is a UCSD Pascal extension.

@subheading Example

@example
program HaltDemo;
begin
  WriteLn ('This string will always be this program''s output.');
  Halt;  @{ Terminate right here and right now. @}
  WriteLn ('And this string won''t ever!')
end.
@end example

@subheading See also

@ref{Break}, @ref{Continue}, @ref{Exit}, @ref{Return}, @ref{goto}.


@c ----------------------------------------------------------------------------


@node High
@unnumberedsec High
@cindex High

@subheading Synopsis

@example
function High (@var{ordinal type or variable}): @var{ordinal type};
@end example
or
@example
function High (@var{array type or variable}): @var{array index type};
@end example
or
@example
function High (@var{string variable}): Integer;
@end example

@subheading Description

For ordinal types or variables of that type, @samp{High} returns the
highest value a variable of that type can assume.

For array types or variables of that type, @samp{High} returns the
highest index a variable of that type can assume. Note: the result is of
the same type as the array index is. If the array has more than one
dimension, @samp{High} returns the highest index in the first dimension.

If the argument is a string variable, @samp{High} returns the
discriminant of the string type (i.e.@: its capacity).

@subheading Conforming to

@samp{High} is a Borland Pascal extension.

@subheading Example

@example
program HighDemo;
type
  Colors = (Red, Green, Blue);
var
  Col: array [Colors] of (Love, Hope, Faithfulness);
  Foo: Colors;
  Bar: Integer;
  Baz: String (123);
begin
  Foo := High (Col);             @{ yields Blue @}
  Bar := Ord (High (Col[Foo]));  @{ yields Ord (Faithfulness), i.e., 2 @}
  Bar := High (Integer);         @{ returns highest possible ``Integer'' @}
  Bar := High (Baz)              @{ returns 123 @}
end.
@end example

@subheading See also

@ref{Low}


@c ----------------------------------------------------------------------------


@node if
@unnumberedsec if
@cindex if

@subheading Synopsis

@example
if @var{Boolean expression} then
  @var{statement}
@end example
or with an alternative statement:
@example
if @var{Boolean expression} then
  @var{statement1}
else
  @var{statement2}
@end example

@subheading Description

The @samp{if @dots{} then} statement executes @var{statement1} depending
on @samp{Boolean expression} being true. If @samp{else} is specified, it
continues executing @var{statement2} instead.

@subheading Conforming to

@samp{if} is defined in ISO-7185 Pascal and supported by all
Pascal variants.

@subheading Example

@example
program IfDemo;
var
  Foo, Bar: Boolean;
begin
  Foo := True;
  Bar := False;
  if ((1 = 1) or (2 = 3)) and (Foo = not Bar) then
    begin
      @{ This is executed if either Foo is true but not Bar or vice versa @}
      WriteLn ('Either Foo or Bar is true.');
      if Bar then
        WriteLn ('You will see this text if Bar is true.')
    end
  else @{ This whole `else' branch is not executed @}
    if 1 = 1 then
      if True = False then
        WriteLn ('This text is never written on screen.')
      else  @{ Note: This ``else'' belongs to ``if True = False'' @}
        WriteLn ('This text is never written on screen as well.')
    else  @{ Note: This ``else'' belongs to ``if 1 = 1'' @}
      WriteLn ('Nor is this.')
end.
@end example

@subheading See also

@ref{if Statement}, @ref{else}, @ref{then}


@c ----------------------------------------------------------------------------


@node Im
@unnumberedsec Im
@cindex Im

@subheading Synopsis

@example
function Im (z: Complex): Real;
@end example

@subheading Description
@samp{Im} extracts the imaginary part of the complex number @samp{z}.
The result is a real value.

@subheading Conforming to

@samp{Im} is an ISO-10206 Extended Pascal extension.

@subheading Example

@example
program ImDemo;
var
  z: Complex;
begin
  z := Cmplx (1, 2);  @{ 1 + i * 2 @}
  WriteLn (Im (z) : 0 : 5)  @{ 2.00000 @}
end.
@end example

@subheading See also

@ref{Cmplx}, @ref{Re}, @ref{Arg}.


@c ----------------------------------------------------------------------------


@node implementation
@unnumberedsec implementation
@cindex implementation

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node import
@unnumberedsec import
@cindex import

@subheading Synopsis

@example
program @@@@fragment foo;

import
  bar1;
  bar3 (baz1 => glork1) in 'baz.pas';
  bar2 only (baz2, baz3 => glork2);

[...]
@end example

@subheading Description

The reserved word @samp{import} in the @emph{import part} of a
program makes the program import an interface.

The @samp{in} above tells GPC to look for the module in the
specified file; otherwise the file name is derived from the name of
the interface by adding first @file{.p}, then @file{.pas} -- which
only works if the name of the exported interface coincides with the
file name.

The symbol @samp{=>} denotes import renaming: The entity which is
exported under the name @samp{baz1} by the interface @samp{bar3}
will be known under the new name @samp{glork1} in the program.

The @samp{only} qualifier means that only the listed identifiers
will be imported from the interface. Renaming works together with
@samp{only}, too.

There must be at most one import part in a program.

The interfaces needn't be exported by Extended Pascal modules but
may be UCSD/Borland Pascal units as well.

@subheading Conforming to

@samp{import} and modules in general are an ISO-10206 Extended
Pascal extension.

GNU Pascal does not yet support @samp{qualified} import.

@subheading Example

@subheading See also

@ref{module}, @ref{unit}, @ref{uses}.


@c ----------------------------------------------------------------------------


@node in
@unnumberedsec in
@cindex in

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Inc
@unnumberedsec Inc
@cindex Inc

@subheading Synopsis

For ordinal types:
@example
procedure Inc (var x: @var{ordinal type});
@end example
or
@example
procedure Inc (var x: @var{ordinal type}; Amount: Integer);
@end example

For pointer types:
@example
procedure Inc (var p: @var{any pointer type});
@end example
or
@example
procedure Inc (var p: @var{any pointer type}; Amount: Integer);
@end example

@subheading Description

For ordinal types, @samp{inc} increases the value of @samp{x} by one or
by @samp{amount} if it is given.

If the argument @samp{p} is pointing to a specified type (typed
pointer), @samp{inc} increases the address of @samp{p} by the size of
the type @samp{p} is pointing to or by @samp{amount} times that size
respectively. If @samp{p} is an untyped pointer (i.e.@: @samp{p} is of
type @ref{Pointer}), @samp{p} is increased by one.

@subheading Conforming to

@samp{Inc} is a Borland Pascal extension.
Yet application of @samp{Inc} to pointers is defined in Borland Pascal.
The combination of the second argument with application to pointers
is a GNU extension.

@subheading Example

@example
program IncDemo;
var
  Foo: Integer;
  Bar: array [1 .. 5] of Integer;
  Baz: ^Integer;
begin
  Foo := 4;
  Inc (Foo, 5);      @{ yields 9 @}
  @{$X+@}              @{ Turn on extended systax @}
  Baz := @@Bar[1];    @{ Baz points to y[1] @}
  Inc (Baz, 2);      @{ Baz points to y[3] @}
end.
@end example

@subheading See also

@ref{Dec}, @ref{Pred}, @ref{Succ}, @ref{Pointer Arithmetics}.


@c ----------------------------------------------------------------------------


@node Include
@unnumberedsec Include
@cindex Include

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Index
@unnumberedsec Index
@cindex Index

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node inherited
@unnumberedsec inherited
@cindex inherited

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Initialize
@unnumberedsec Initialize
@cindex Initialize

(Under construction.)

@subheading Synopsis

@example
procedure Initialize (var Aynthing);
@end example

@subheading Description

@samp{Initialize} does all necessary initializations for the
parameter (e.g., setting of string and schema discriminants, and
object VMT pointers, initialization of file variables). This is
normally done automatically at the start of the lifetime of a
variable, so you need to call @samp{Initialize} only in special
situations, e.g. when you allocate a dynamic variable with
@samp{GetMem} rather than @samp{New}.

@subheading Conforming to

@samp{Initialize} is a Delphi extension.

@subheading Example

@subheading See also

@ref{Finalize}, @ref{New}, @ref{GetMem}.


@c ----------------------------------------------------------------------------


@node inline
@unnumberedsec inline
@cindex inline

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node InOutRes
@unnumberedsec InOutRes
@cindex InOutRes

(Under construction.)

@subheading Synopsis

@example
var
  InOutRes: Integer;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Input
@unnumberedsec Input
@cindex Input

(Under construction.)

@subheading Synopsis

@example
var
  Input: Text;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Insert
@unnumberedsec Insert
@cindex Insert

(Under construction.)

@subheading Synopsis

@example
procedure Insert (Source: String; var Dest: String; Position: Integer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Int
@unnumberedsec Int
@cindex Int

(Under construction.)

@subheading Synopsis

@example
function Int (x: Real): Real;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Integer
@unnumberedsec Integer
@cindex Integer

@subheading Synopsis

@example
type
  Integer  @{ built-in type @}
@end example
or
@example
type
  Integer (n)  @{ built-in type class @}
@end example

@subheading Description

@samp{Integer} is the ``natural'' signed integer type in GNU Pascal.
On most platforms it is 32 bits wide and thus has a range of
@samp{-2147483648 .. 2147483647}.  Use it whenever you need a
general-purpose signed integer type.

As an extension, GPC allows to use @samp{Integer} as a pseudo-schema
to produce types with a specified size in bits; for example

@example
type
  Int16 = Integer (16);
@end example

defines an integer type with 16 bits.  The same mechanism works for
@samp{Cardinal} and @samp{Word}, too.

@samp{Integer} in GNU Pascal is compatible to @samp{Int} in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

In ISO Pascal, @samp{Integer} is the only built-in integer type.
(However see @ref{Subrange Types}.)

@subheading Example

@example
program IntegerDemo;
var
  a: Integer;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node interface
@unnumberedsec interface
@cindex interface

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node interrupt
@unnumberedsec interrupt
@cindex interrupt

Not yet implemented.

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node IOResult
@unnumberedsec IOResult
@cindex IOResult

(Under construction.)

@subheading Synopsis

@example
function IOResult: Integer;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node is
@unnumberedsec is
@cindex is

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also

@ref{as}, @ref{TypeOf}, @ref{OOP}.


@c ----------------------------------------------------------------------------


@node label
@unnumberedsec label
@cindex label

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node LastPosition
@unnumberedsec LastPosition
@cindex LastPosition

(Under construction.)

@subheading Synopsis

@example
function LastPosition (var F: @var{typed file}): Integer;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node LE
@unnumberedsec LE
@cindex LE

(Under construction.)

@subheading Synopsis

@example
function LE (S1, S2: String): Boolean;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Length
@unnumberedsec Length
@cindex Length

(Under construction.)

@subheading Synopsis

@example
function Length (S: String): Integer;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node library
@unnumberedsec library
@cindex library

Not yet implemented.

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Ln
@unnumberedsec Ln
@cindex Ln

@subheading Synopsis

@example
function Ln (x: Real): Real;
@end example
or
@example
function Ln (z: Complex): Complex;
@end example

@subheading Description

The natural logarith @samp{Ln} is the logarithm with base e, where e
is the Euler number e = Exp (1) = 2.718281828@dots{}

@subheading Conforming to

The function @samp{Ln} is defined in ISO-7185 Pascal; its
application to complex values is defined in ISO-10206 Extended
Pascal.

@subheading Example

@example
program LnDemo;
var
  z: Complex;
begin
  z := Cmplx (1, 1);
  z := Ln (z)  @{ yields Ln (SqRt (2)) + i * Pi / 4 @}
               @{ since Ln (i * x) = Ln Abs (x) + i * Arg (x) @}
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node LoCase
@unnumberedsec LoCase
@cindex LoCase

(Under construction.)

@subheading Synopsis

@example
function LoCase (Ch: Char): Char;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node LongBool
@unnumberedsec LongBool
@cindex LongBool

(Under construction.)

@subheading Synopsis

@example
type
  LongBool = Boolean (BitSizeOf (LongInt));
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program LongBoolDemo;
var
  a: LongBool;
begin
  LongInt (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node LongCard
@unnumberedsec LongCard
@cindex LongCard

@subheading Synopsis

@example
type
  LongCard = Cardinal (BitSizeOf (LongInt));
@end example

@subheading Description

@samp{LongCard} is an unsigned integer type which is longer than
@samp{Cardinal}.  On most platforms it is 64 bits wide and thus has
a range of @samp{0..18446744073709551615}.

@samp{LongCard} in GNU Pascal is compatible to @samp{long long unsigned int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongCard} is a GNU Pascal extension.

@subheading Example

@example
program LongCardDemo;
var
  a: LongCard;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node LongestBool
@unnumberedsec LongestBool
@cindex LongestBool

(Under construction.)

@subheading Synopsis

@example
type
  LongestBool = Boolean (BitSizeOf (LongestInt));
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program LongestBoolDemo;
var
  a: LongestBool;
begin
  LongestInt (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node LongestCard
@unnumberedsec LongestCard
@cindex LongestCard

@subheading Synopsis

@example
type
  LongestCard = Cardinal (BitSizeOf (LongestInt));
@end example

@subheading Description

@samp{LongestCard} is GPC's longest-possible unsigned integer type.
Currently, this is the same as @ref{LongCard}.
On most platforms it is 64 bits wide and thus has
a range of @samp{0..18446744073709551615}.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongestCard} is a GNU Pascal extension.

@subheading Example

@example
program LongestCardDemo;
var
  a: LongestCard;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node LongestInt
@unnumberedsec LongestInt
@cindex LongestInt

@subheading Synopsis

@example
type
  LongestInt = LongInt;  @{ might get bigger than LongInt someday @}
@end example

@subheading Description

@samp{LongestInt} is GPC's longest-possible signed integer type.
Currently, this is the same as @ref{LongInt}.
On most platforms it is 64 bits wide and thus has
a range of @samp{-9223372036854775808..9223372036854775807}.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongestInt} is a GNU Pascal extension.

@subheading Example

@example
program LongestIntDemo;
var
  a: LongestInt;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node LongestReal
@unnumberedsec LongestReal
@cindex LongestReal

(Under construction.)

@subheading Synopsis

@example
type
  LongestReal = LongReal;  @{ might get bigger than LongReal someday @}
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program LongestRealDemo;
var
  a: LongestReal;
begin
  a := 42;
  WriteLn (a)
end.
@end example


@subheading See also


@c ----------------------------------------------------------------------------


@node LongestWord
@unnumberedsec LongestWord
@cindex LongestWord

@subheading Synopsis

@example
type
  LongestWord = LongestCard;
@end example

@subheading Description

@samp{LongestWord} is GPC's longest-possible unsigned integer type.
Currently, this is the same as @ref{LongWord}.
On most platforms it is 64 bits wide and thus has
a range of @samp{0..18446744073709551615}.  (It is the same as
@ref{LongestCard}.)

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongestWord} is a GNU Pascal extension.

@subheading Example

@example
program LongestWordDemo;
var
  a: LongestWord;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node LongInt
@unnumberedsec LongInt
@cindex LongInt

@subheading Synopsis

@example
type
  LongInt  @{ built-in type @}
@end example

@subheading Description

@samp{LongInt} is a signed integer type which is longer than
@samp{Integer}.  On most platforms it is 64 bits wide and thus has
a range of @samp{-9223372036854775808..9223372036854775807}.

@samp{LongInt} in GNU Pascal is compatible to @samp{long long int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongInt} is a Borland Pascal extension.  Borland Pascal
defines @samp{LongInt} as a 32-bit signed integer type
(@ref{Integer} in GNU Pascal).

@subheading Example

@example
program LongIntDemo;
var
  a: LongInt;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node LongReal
@unnumberedsec LongReal
@cindex LongReal

(Under construction.)

@subheading Synopsis

@example
type
  LongReal  @{ built-in type @}
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program LongRealDemo;
var
  a: LongReal;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node LongWord
@unnumberedsec LongWord
@cindex LongWord

@subheading Synopsis

@example
type
  LongWord = LongCard;
@end example

@subheading Description

@samp{LongWord} is an unsigned integer type which is larger than
@samp{Word}.  On most platforms it is 64 bits wide and thus has
a range of @samp{0..18446744073709551615}.  It is the same as
@ref{LongCard}.

@samp{LongWord} in GNU Pascal is compatible to @samp{long long unsigned int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongWord} is a GNU Pascal extension.

@subheading Example

@example
program LongWordDemo;
var
  a: LongWord;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node Low
@unnumberedsec Low
@cindex Low

@subheading Synopsis

@example
function Low (@var{ordinal type or variable}): @var{ordinal type};
@end example
or
@example
function Low (@var{array type or variable}): @var{array element type};
@end example
or
@example
function Low (@var{string variable}): Integer;
@end example

@subheading Description

For ordinal types or variables of that type, @samp{Low} returns the
lowest value a variable of that type can assume.

For array types or variables of that type, @samp{Low} returns the
lowest index a variable of that type can assume. Note: the result is
of the same type as the array index is. If the array has more than
one dimension, @samp{Low} returns the lowest index in the first
dimension.

If the argument is a string variable, @samp{Low} returns one.

@subheading Conforming to

@subheading Example

@example
program LowDemo;
type
  Colors = (Red, Green, Blue);
var
  Col: array [12 .. 20] of Colors;
  Foo: 12 .. 20;
  Bar: Integer;
begin
  Foo := Low (Col);            @{ returns 12 @}
  Col[Foo] := Low (Col[Foo]);  @{ returns Red @}
  Bar := Low (Integer)         @{ returns lowest ``Integer'' value @}
end.
@end example

@subheading See also

@ref{High}


@c ----------------------------------------------------------------------------


@node LT
@unnumberedsec LT
@cindex LT

(Under construction.)

@subheading Synopsis

@example
function LT (S1, S2: String): Boolean;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Mark
@unnumberedsec Mark
@cindex Mark

(Under construction.)

@subheading Synopsis

@example
procedure Mark (var P: Pointer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Max
@unnumberedsec Max
@cindex Max

(Under construction.)

@subheading Synopsis

@example
function Max (x1, x2: @var{ordinal or real type}): @var{same type};
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MaxChar
@unnumberedsec MaxChar
@cindex MaxChar

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MaxInt
@unnumberedsec MaxInt
@cindex MaxInt

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MaxReal
@unnumberedsec MaxReal
@cindex MaxReal

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MedBool
@unnumberedsec MedBool
@cindex MedBool

(Under construction.)

@subheading Synopsis

@example
type
  MedBool = Boolean (BitSizeOf (MedInt));
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program MedBoolDemo;
var
  a: MedBool;
begin
  MedInt (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node MedCard
@unnumberedsec MedCard
@cindex MedCard

@subheading Synopsis

@example
type
  MedCard = Cardinal (BitSizeOf (MedInt));
@end example

@subheading Description

@samp{MedCard} is an unsigned integer type which is not smaller than
@samp{Cardinal}.  On most platforms it actually is the same as @samp{Cardinal}
and 32 bits wide and thus has a range of @samp{0..4294967295}.

@samp{MedCard} in GNU Pascal is compatible to @samp{long unsigned int}
in GNU C.  This compatibility is the reason why @samp{MedCard} exists.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{MedCard} is a GNU Pascal extension.

@subheading Example

@example
program MedCardDemo;
var
  a: MedCard;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node MedInt
@unnumberedsec MedInt
@cindex MedInt

@subheading Synopsis

@example
type
  MedInt  @{ built-in type @}
@end example

@subheading Description

@samp{MedInt} is a signed integer type which is not smaller than
@samp{Integer}.  On most platforms it actually is the same as @samp{Integer}
and 32 bits wide and thus has a range of @samp{-2147483648..2147483647}.

@samp{MedInt} in GNU Pascal is compatible to @samp{long int}
in GNU C.  This compatibility is the reason why @samp{MedInt} exists.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{MedInt} is a GNU Pascal extension.

@subheading Example

@example
program MedIntDemo;
var
  a: MedInt;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node MedReal
@unnumberedsec MedReal
@cindex MedReal

(Under construction.)

@subheading Synopsis

@example
type
  MedReal = Real;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program MedRealDemo;
var
  a: MedReal;
begin
  a := 42;
  WriteLn (a)
end.
@end example


@subheading See also


@c ----------------------------------------------------------------------------


@node MedWord
@unnumberedsec MedWord
@cindex MedWord

@subheading Synopsis

@example
type
  MedWord = MedCard;
@end example

@subheading Description

@samp{MedWord} is an unsigned integer type which is not smaller than
@samp{Word}.  On most platforms it actually is the same as @samp{Word}
and 32 bits wide and thus has a range of @samp{0..4294967295}.  It is
the same as @ref{MedCard}.

@samp{MedWord} in GNU Pascal is compatible to @samp{long unsigned int}
in GNU C.  This compatibility is the reason why @samp{MedWord} exists.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{MedWord} is a GNU Pascal extension.

@subheading Example

@example
program MedWordDemo;
var
  a: MedWord;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node Min
@unnumberedsec Min
@cindex Min

(Under construction.)

@subheading Synopsis

@example
function Min (x1, x2: @var{ordinal or real type}): @var{same type};
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MinReal
@unnumberedsec MinReal
@cindex MinReal

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MkDir
@unnumberedsec MkDir
@cindex MkDir

@subheading Synopsis

@example
procedure MkDir (Directory: String);
@end example

@subheading Description

@samp{MkDir} creates the given @var{Directory}, if its argument is a
valid parameter to the related operating system's function.
Otherwise a runtime error is caused.

@subheading Conforming to

@samp{MkDir} is a Borland Pascal extension.

@subheading Example

@example
program MkDirDemo;
var
  Foo: String (127);
begin
  WriteLn ('Enter directory name to create:');
  ReadLn (Foo);
  @{$I-@}  @{ Don't abort program on error @}
  MkDir (Foo);
  if IOResult <> 0 then
    WriteLn ('Directory `', Foo, ''' could not be created')
  else
    WriteLn ('Okay')
end.
@end example

@subheading See also

@ref{ChDir}, @ref{RmDir}


@c ----------------------------------------------------------------------------


@node mod
@unnumberedsec mod
@cindex mod

(Under construction.)

@subheading Synopsis

@example
operator mod (p, q: Integer) = r: Integer;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node module
@unnumberedsec module
@cindex module

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Move
@unnumberedsec Move
@cindex Move

(Under construction.)

@subheading Synopsis

@example
procedure Move (const Source; var Dest; Count: Integer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MoveLeft
@unnumberedsec MoveLeft
@cindex MoveLeft

(Under construction.)

@subheading Synopsis

@example
procedure MoveLeft (const Source; var Dest; Count: Integer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MoveRight
@unnumberedsec MoveRight
@cindex MoveRight

(Under construction.)

@subheading Synopsis

@example
procedure MoveRight (const Source; var Dest; count: Integer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Name
@unnumberedsec Name
@cindex Name

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node NE
@unnumberedsec NE
@cindex NE

(Under construction.)

@subheading Synopsis

@example
function NE (S1, S2: String): Boolean;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node near
@unnumberedsec near
@cindex near

@subheading Synopsis

@subheading Description

The @samp{near} directive can be appended to a procedure or function
heading but is ignored by GPC. It is there for Borland compatibility,
only. (Since the GNU compilers provide a flat memory model, the
distinction between @samp{near} and @samp{near} pointers is void.)

@subheading Conforming to

@samp{near} is a Borland Pascal extension.

@subheading Example

@example
program NearDemo;

var
  p: procedure;

@{$W-@}  @{ Don't warn about the uselessness of `near' @}

procedure Foo; near;  @{ `near' has no effect in GPC @}
begin
  WriteLn ('Foo')
end;

begin
  p := Foo;  @{ Works, despite the `near'. @}
  p
end.
@end example

@subheading See also

@ref{far}.


@c ----------------------------------------------------------------------------


@node New
@unnumberedsec New
@cindex New

(Under construction.)

@subheading Synopsis

@example
procedure New (var P: @var{any Pointer});
@end example
or
@example
procedure New (var P: @var{Pointer to a variant record}; @var{tag fields});
@end example
or
@example
procedure New (var P: @var{Pointer to a schema}; @var{discriminants});
@end example
or
@example
procedure New (var P: @var{Pointer to an object}; @var{constructor call});
@end example
or
@example
function New (@var{any Pointer type}): @var{same type};
@end example
or
@example
function New (@var{variant record Pointer type};
              @var{tag fields}): @var{same type};
@end example
or
@example
function New (@var{schema Pointer type};
              @var{discriminants}): @var{same type};
@end example
or
@example
function New (@var{object Pointer type};
              @var{constructor call}): @var{same type};
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node NewCString
@unnumberedsec NewCString
@cindex NewCString

(Under construction.)

@subheading Synopsis

@example
function NewCString (const S: String): CString;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node nil
@unnumberedsec nil
@cindex nil

@subheading Synopsis

@samp{nil} is a predefined constant

@subheading Description

@samp{nil} is a predefined pointer constant that indicates an
unassigned pointer. ``nil'' stands for ``not in list''. @emph{Every}
pointer type can be associated with this constant.

@subheading Conforming to

@samp{nil} is defined in ISO-7185 Pascal and
supported by all known Pascal variants.

@subheading Example

@example
program NilDemo;
const
  NodeNum = 10;
type
  PNode = ^TNode;
  TNode = record
    Key: Integer;
    Next: PNode
  end;
var
  Root, Node: PNode;
  Foo: Integer;
begin
  New (Root);
  Root^.Key := 1;             @{ Set root key @}
  Node := Root;
  for Foo := 2 to NodeNum do  @{ Create linked list with NODE_NUM nodes @}
    begin
      New (Node^.Next);
      Node := Node^.Next;
      Node^.Key := Foo        @{ Set key @}
    end;
  Node^.Next := nil;          @{ Mark end of linked list @}
  @{ Shorten list by removing its first element until list is empty @}
  while Root <> nil do
    begin
      Node := Root;
      WriteLn ('Current key:', Root^.Key);
      Root := Root^.Next;
      Dispose (Node);
      Node := nil             @{ Indicate old node is not assigned @}
    end
end.
@end example

@subheading See also

@ref{Assigned}, @ref{Pointer}


@c ----------------------------------------------------------------------------


@node not
@unnumberedsec not
@cindex not

(Under construction.)

@subheading Synopsis

@example
operator not (b1, b2: Boolean) = Result: Boolean;
@end example
or
@example
operator not (i1, i2: @var{integer type}) = Result: @var{integer type};
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Null
@unnumberedsec Null
@cindex Null

@subheading Synopsis

@example
var
  Null: Void absolute 0;
@end example

@subheading Description

@samp{Null} is a predefined variable at address @samp{nil}.
@samp{Null} can be passed as a ``void'' argument to a procedure,
function or operator expecting a ``var'' parameter. @emph{Note}:
Make sure they can handle this case, otherwise this is likely to
cause an exception and the program will be terminated. Since
@samp{Null} is an L-value, it can be taken as ``nil-reference''.

@subheading Conforming to

@samp{Null} is a Borland Delphi extension.

@subheading Example

@example
program NullDemo;
type
  PString = ^String;
var
  Com1: String (25) = 'This is an amazing number';
  Com2: String (25) = 'This is a boring number';

procedure FooBar (Foo: Integer; var Comment: PString);
begin
  if Odd (Foo) then
    WriteLn ('FooBar:', Foo, ' is odd')
   else
    WriteLn ('FooBar:', Foo, ' is even');
  if @@Comment <> nil then
    if not Odd(foo) then
      Comment := @@Com1
    else
      Comment := @@Com2
end;

var
  S: String (25);
  P: PString value @@S;

begin
  @{ FooBar allows you to leave out variables
    for any information you might not need @}
  FooBar (1, Null);
  @{ But FooBar is flexible, after all @}
  FooBar (6, p);
  WriteLn ('FooBar said about 6: `', P^, '''')
end.
@end example

@subheading See also

@ref{nil}


@c ----------------------------------------------------------------------------


@node object
@unnumberedsec object
@cindex object

@subheading Synopsis

@subheading Description

The keyword @samp{object} is used to declare a new object type:

@example
type
  foo = object
    a: Integer;
    constructor Init;
    procedure Bar (x: Integer); virtual;
  end;
@end example

(For a longer example, see @ref{OOP}.)

@subheading Conforming to

GNU Pascal follows the Borland Pascal 7.0 object model.

ISO Pascal does not support Object-orientated programming. There
is an ANSI draft for an ``Object Pascal'' language which is not yet
supported by GPC, but planned. The Delphi language, also called
``Object Pascal'' by Borland, is currently not supported by GPC either.

@subheading Example

@subheading See also

@ref{OOP},
@ref{record}.


@c ----------------------------------------------------------------------------


@node Odd
@unnumberedsec Odd
@cindex Odd

@subheading Synopsis

@example
function Odd (i: Integer): Boolean;
@end example

@subheading Description

@samp{Odd} checks the parity of its argument @samp{i}. It returns
@samp{True} if the argument is odd, @samp{False} if it is even.

@subheading Conforming to

@samp{Odd} is defined in ISO-7185 Pascal and
supported by all known Pascal variants.

@subheading Example

@example
program OddDemo;
var
  Foo: Integer;
begin
  Write ('Please enter an odd number: ');
  ReadLn (Foo);
  if not Odd (Foo) then
    WriteLn ('Odd''s not even! Something''s odd out there ...')
  else
    WriteLn (Foo, ' is pretty odd.')
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node of
@unnumberedsec of
@cindex of

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node only
@unnumberedsec only
@cindex only

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node operator
@unnumberedsec operator
@cindex operator

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node or
@unnumberedsec or
@cindex or

@subheading Synopsis

@example
operator or (operand1, operand2: Boolean) = Result: Boolean;
@end example
or
@example
operator or (operand1, operand2: @var{integer type}) = Result: @var{integer type};
@end example
or
@example
procedure or (var operand1: @var{integer type}; operand2: @var{integer type});
@end example

@subheading Description

In GNU Pascal, @samp{or} has three built-in meanings:

@enumerate

@item
Logical ``or'' between two @samp{Boolean}-type expressions.
The result of the operation is of @samp{Boolean} type.

By default, @samp{or} acts as a short-circuit operator in GPC:  If the first
operand is @samp{True}, the second operand is not evaluated because the result
is already known to be @samp{True}.  You can change this to complete
evaluation using the @samp{--no-short-circuit} command-line option or the
@samp{@{$B+@}} compiler directive.

@item
Bitwise ``or'' between two integer-type expressions.
The result is of the common integer type of both expressions.

@item
Use as a ``procedure'':  @samp{operand1} is ``or''ed bitwise with
@samp{operand2}; the result is stored in @samp{operand1}.

@end enumerate

@subheading Conforming to

The logical @samp{or} operator is defined in ISO-7185
Pascal.

According to ISO, you cannot rely on @samp{or} being a short-circuit
operator. On the other hand, GPC's default behaviour does @emph{not}
contradict the ISO standard. (See @ref{or_else}.) However, since it
seems to be a de-facto standard among ISO Pascal compilers to
evaluate both operands of @samp{or}, GPC switches to
@samp{--no-short-circuit} mode if one of the language dialect
options selecting ISO Pascal, for instance @samp{--extended-pascal},
is given. Use @samp{--short-circuit} to override.

Use of @samp{or} as a bitwise operator for integers is a Borland
Pascal extension.

Use of @samp{or} as a ``procedure'' is a GNU Pascal extension.

@subheading Example

@example
program OrDemo;
var
  a, b, c: Integer;
begin
  if (a = 0) or (b = 0) then  @{ logical `or' @}
    c := 1
  else if a or b = 0 then  @{ bitwise `or' @}
    c := 2
  else
    or (c, a)  @{ same as `c := c or a' @}
end.
@end example

Note the difference between the logical @samp{or} and the bitwise
@samp{or}: When @samp{a} is 2 and @samp{b} is 4, then @samp{a or b}
is 6. @strong{Beware:} @samp{a or b = 0} happens to mean the same as
@samp{(a = 0) and (b = 0)}. (Note the @samp{and}!)

Since bitwise @samp{or} has a higher priority than the @samp{=}
operator, parentheses are needed in @samp{if (a = 0) or (b = 0)}
because otherwise @samp{0 or b} would be calculated first, and the
remainder would cause a parse error.

@subheading See also

@ref{and}, @ref{xor}, @ref{Operators}.


@c ----------------------------------------------------------------------------


@node Ord
@unnumberedsec Ord
@cindex Ord

(Under construction.)

@subheading Synopsis

@example
function Ord (Ch: Char): Integer;
@end example

@subheading Description

@subheading Conforming to

@samp{Ord} is defined in ISO-7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node or else
@unnumberedsec or else
@cindex or else

@subheading Synopsis

@example
@{ `or else' is built in. A user-defined operator cannot consist of
   two words. @}
operator or else (operand1, operand2: Boolean) = Result: Boolean;
@end example

@subheading Description

@samp{or else} is an alias for the short-circuit logical operator
@samp{or_else}.

@subheading Conforming to

While @samp{or_else} is defined in ISO-10206 Extended Pascal,
@samp{or else} is a GNU Extension.

@subheading Example

@example
program OrElseDemo;
var
  a: Integer;
begin
  ReadLn (a);
  if (a = 0) or else (100 div a > 42) then  @{ This is safe. @}
    WriteLn ('100 div a > 42')
end.
@end example

@subheading See also

@ref{or_else}, @ref{or}, @ref{and then}.


@c ----------------------------------------------------------------------------


@node or_else
@unnumberedsec or_else
@cindex or_else

@subheading Synopsis

@example
operator or_else (operand1, operand2: Boolean) = Result: Boolean;
@end example

@subheading Description

The @samp{or_else} short-circuit logical operator performs the same
operation as the logical operator @samp{or}. But while the ISO
standard does not specify anything about the evaluation of the
operands of @samp{or} -- they may be evaluated in any order, or not
at all -- @samp{or_else} has a well-defined behaviour: It evaluates
the first operand. If the result is @samp{True}, @samp{or_else}
returns @samp{True} without evaluating the second operand. If it is
@samp{False}, the second operand is evaluated and returned.

GPC by default treats @samp{or} and @samp{or_else} exactly the same.
If you want, for some reason, to have both operands of @samp{or}
evaluated completely, you must assign both to temporary variables
and then use @samp{or} -- or @samp{or_else}, it does not matter.

@subheading Conforming to

@samp{or_else} is an ISO-10206 Extended Pascal extension.

Some people think that the ISO standard requires both operands of
@samp{or} to be evaluated. This is false. What the ISO standard
@emph{does} say is that you cannot rely on a certain order of
evaluation of the operands of @samp{or}; in particular things like
the following program can crash according to ISO Pascal, although
they cannot crash when compiled with GNU Pascal running in default
mode.

@example
program OrBug;
var
  a: Integer;
begin
  ReadLn (a);
  if (a = 0) or (100 div a > 42) then  @{ This is NOT safe! @}
    WriteLn ('You''re lucky. But the test could have crashed ...')
end.
@end example

@subheading Example

@example
program Or_ElseDemo;
var
  a: Integer;
begin
  ReadLn (a);
  if (a = 0) or_else (100 div a > 42) then  @{ This is safe. @}
    WriteLn ('100 div a > 42')
end.
@end example

@subheading See also

@ref{or else}, @ref{or}, @ref{and_then}.


@c ----------------------------------------------------------------------------


@node otherwise
@unnumberedsec otherwise
@cindex otherwise

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Output
@unnumberedsec Output
@cindex Output

(Under construction.)

@subheading Synopsis

@example
var
  Output: Text;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Override
@unnumberedsec Override
@cindex Override

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Pack
@unnumberedsec Pack
@cindex Pack

(Under construction.)

@subheading Synopsis

@subheading Description

@example
procedure Pack (Source: @var{unpacked array};
                FirstElement: @var{index type};
                var Dest: @var{packed array});
@end example

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node packed
@unnumberedsec packed
@cindex packed

@subheading Synopsis

@subheading Description

@samp{packed} is a reserved word. According to ISO-7185
Pascal it can precede @samp{array} and @samp{record} type
definitions to indicate that memory usage should be minimized for
variables of this type, possibly at the expense of loss of speed.

As a GNU extension, @samp{packed} can also be applied to
@ref{Subrange Types}.

@subheading Conforming to

The reserved word @samp{packed} is defined in ISO-7185 Pascal.

According to ISO standard, only @emph{packed} arrays of char with lower
bound 1 qualify as strings of fixed length. GNU Pascal neither requires
@samp{packed} nor the lower bound of 1 here.

@subheading Example

@example
program PackedDemo;

type
  MonthInt = packed 1 .. 12;  @{ needs one byte   @}
  FastMonthInt = 1 .. 12;     @{ needs four bytes @}

  FixString10 = packed array [1 .. 10] of Char;
  FoxyString10 = array [0 .. 9] of Char;

  Flags = packed array [1 .. 32] of Boolean;  @{ needs four Bytes @}

  DateRec = packed record
    Day: 1 .. 31;       @{ five bits @}
    Month: MonthInt;    @{ four bits @}
    Year: Integer (15)  @{ 15 bits = -16384 .. 16383 @}
  end;

  Dates = array [1 .. 1000] of DateRec;

var
  S: FixString10;
  T: FoxyString10;

begin
  S := 'Hello!';   @{ blank padded @}
  WriteLn (S);

  T := 'GNU Pascal';  @{ GPC extension: this also works. @}
  WriteLn (T)
end.
@end example

@samp{DateRec} has 24 bits = 3 bytes in total; @samp{Dates} has 3000 bytes.

@subheading See also

@ref{Pack}, @ref{Unpack}, @ref{SizeOf}, @ref{AlignOf}, @ref{BitSizeOf}.


@c ----------------------------------------------------------------------------


@node Page
@unnumberedsec Page
@cindex Page

(Under construction.)

@subheading Synopsis

@example
procedure Page (var F: Text);
@end example
or
@example
procedure Page;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node PAnsiChar
@unnumberedsec PAnsiChar
@cindex PAnsiChar

(Under construction.)

@subheading Synopsis

@example
type
  PAnsiChar = ^AnsiChar;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program PAnsiCharDemo;
var
  s: PAnsiChar;
begin
  s := 'Hello, world!';
  @{$X+@}
  WriteLn (s)
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node ParamCount
@unnumberedsec ParamCount
@cindex ParamCount

@subheading Synopsis

@example
function ParamCount: Integer;
@end example

@subheading Description

@samp{ParamCount} returns the number of command-line arguments given to the
program.  @samp{ParamCount} returns 0 if no arguments have been given to
the program; the name of the program as an implicit argument is not counted.

@subheading Conforming to

@samp{ParamCount} is a Borland Pascal extension.

@subheading Example

@example
program ParamCountDemo;

var
  i: Integer;

begin
  WriteLn ('You have invoked this program with ',
           ParamCount, ' arguments.');
  WriteLn ('These are:');
  for i := 1 to ParamCount do
    WriteLn (ParamStr (i))
end.
@end example

@subheading See also

@ref{ParamStr}.


@c ----------------------------------------------------------------------------


@node ParamStr
@unnumberedsec ParamStr
@cindex ParamStr

(Under construction.)

@subheading Synopsis

@example
function ParamStr (ParmNumber: Integer): String;
@end example

@subheading Description

@strong{Note:} If you are using the Dos (DJGPP) or MS-Windows
(mingw32) version of GPC and are getting unexpected results from
@samp{ParamStr}, please see the section ``Command-line Arguments
Handling in DJGPP'' of the DJGPP FAQ list.

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node PChar
@unnumberedsec PChar
@cindex PChar

(Under construction.)

@subheading Synopsis

@example
type
  PChar = ^Char;
@end example
or
@example
type
  PChar = CString;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program PCharDemo;
var
  s: PChar;
begin
  s := 'Hello, world!';
  @{$X+@}
  WriteLn (s)
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node Pi
@unnumberedsec Pi
@cindex Pi

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node PObjectType
@unnumberedsec PObjectType
@cindex PObjectType

@subheading Synopsis

@example
type
  PObjectType = ^const record
    Size:    SizeType;
    NegSize: Integer (BitSizeOf (SizeType));
    Parent:  PObjectType;
    Name:    ^const String
  end;
@end example

(Note: @samp{^record} is not valid syntax. It is just used here for
explanation because the record type itself is not declared.)

@subheading Description

The type returned by @samp{TypeOf} and required by @samp{SetType}.
In fact, the record pointed to (the VMT) also contains pointers to
the virtual methods. However, these are not declared in
@samp{PObjectType} because they vary from object type to object type.
The fields declared here are those that can be accessed (via
@samp{TypeOf}) for every object type.

@samp{Size} contains the size of the object type, @samp{NegSize}
contains the size negated (for runtime checks). @samp{Parent}
contains a pointer to the parent type's VMT (or nil if the type has
no parent or the parent type is abstract). @samp{Name} points to a
string containing the type's name.

@subheading Conforming to

@samp{PObjectType} is a GNU Pascal extension

@subheading Example

@subheading See also

@ref{TypeOf}, @ref{SetType}, @ref{OOP}.


@c ----------------------------------------------------------------------------


@node Pointer
@unnumberedsec Pointer
@cindex Pointer

(Under construction.)

@subheading Synopsis

@example
type
  Pointer  @{ built-in type @}
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program PointerDemo;
var
  a: Integer;
  b: Boolean;
  p: Pointer;
begin
  p := nil;
  p := @@a;
  p := @@b
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node Polar
@unnumberedsec Polar
@cindex Polar

(Under construction.)

@subheading Synopsis

@example
function Polar (rho, phi: Real): Complex;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Pos
@unnumberedsec Pos
@cindex Pos

(Under construction.)

@subheading Synopsis

@example
function Pos (SearchPattern, Source: String): Integer;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Position
@unnumberedsec Position
@cindex Position

(Under construction.)

@subheading Synopsis

@example
function Position (var F: @var{typed file});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node pow
@unnumberedsec pow
@cindex pow

(Under construction.)

@subheading Synopsis

@example
operator pow (base: Real; exponent: Integer) = power: Real;
@end example
or
@example
operator pow (base: Complex; exponent: Integer) = power: Complex;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Pred
@unnumberedsec Pred
@cindex Pred

@subheading Synopsis

@example
function Pred (i: @var{ordinal type}): @var{ordinal type};
@end example
or
@example
function Pred (i: @var{ordinal type}; j: Integer): @var{ordinal type};
@end example

or, with extended syntax (@samp{--extended-syntax} or @samp{@{$X+@}}),

@example
function Pred (p: @var{Pointer type}): @var{Pointer type};
@end example
or
@example
function Pred (p: @var{Pointer type}; j: Integer): @var{Pointer type};
@end example

@subheading Description

Returns the predecessor of the @var{ordinal type} value @samp{i}, or, if the
second argument @samp{j} is given, its @samp{j}th predecessor.  For integer
values @samp{i}, this is @samp{i - 1} (or @samp{i - j}).  (No, @samp{Pred}
does @emph{not} work faster than plain subtraction.  Both are optimized to a
single machine instruction or even expanded by the compiler, if possible.)

If extended syntax is on, the argument may also be a pointer value.  In this
case, the address is decremented by the size of the variable pointed to, or,
if @samp{j} is given, by @samp{j} times the size of the variable pointed to.
If @samp{p} points to an element of an array, the returned pointer will point
to the (@samp{j}th) previous element of the array.


@subheading Conforming to

The @samp{Pred} function is defined in ISO-7185 Pascal.  The optional
second parameter is defined in ISO-10206 Extended Pascal.  Application of
@samp{Pred} to pointers is defined in Borland Pascal.  The combination of the
second argument with application to pointers is a GNU extension.

@subheading Example

@example
program PredDemo;

type
  Metasyntactical = (foo, bar, baz);

var
  m: Metasyntactical;
  c: Char;
  a: array [1 .. 7] of Integer;
  p: ^Integer;

begin
  m := Pred (bar);     @{ foo @}
  c := Pred ('Z', 2);  @{ 'X' @}
  a[1] := 42;
  a[4] := Pred (a[1]);     @{ 41 @}
  a[5] := Pred (a[4], 3);  @{ 38 @}
  @{$X+@}
  p := @@a[5];
  p := Pred (p);     @{ now p points to a[4] @}
  p := Pred (p, 3);  @{ now p points to a[1] @}
end.
@end example

@subheading See also

@ref{Succ}, @ref{Dec}, @ref{Pointer Arithmetics}.


@c ----------------------------------------------------------------------------


@node private
@unnumberedsec private
@cindex private

(Under construction.)

@subheading Synopsis

@subheading Description

GPC currently accepts but ignores the @samp{private} directive
in object type declarations.

@subheading Conforming to

@subheading Example

@subheading See also

@ref{protected}, @ref{public}, @ref{published}.


@c ----------------------------------------------------------------------------


@node procedure
@unnumberedsec procedure
@cindex procedure

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node program
@unnumberedsec program
@cindex program

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node property
@unnumberedsec property
@cindex property

Not yet implemented.

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node protected
@unnumberedsec protected
@cindex protected

(Under construction.)

@subheading Synopsis

@subheading Description

The Extended Pascal meaning of @samp{protected} is supported by GPC.

GPC currently accepts but ignores the @samp{protected} directive
in object type declarations.

@subheading Conforming to

Extended Pascal and Borland Pascal, but with different meanings.

@subheading Example

@subheading See also

@ref{const}, @ref{import}, @ref{private}, @ref{public}, @ref{published}.


@c ----------------------------------------------------------------------------


@node PtrCard
@unnumberedsec PtrCard
@cindex PtrCard

(Under construction.)

@subheading Synopsis

@example
type
  PtrCard = Cardinal (BitSizeOf (Pointer));
@end example

@subheading Description

An unsigned integer type of the same size as a pointer.

@subheading Conforming to

@subheading Example

@example
program PtrCardDemo;
var
  a: PtrCard;
  p: Pointer;
begin
  GetMem (p, 10);
  a := PtrCard (p);
  Inc (a);
  p := Pointer (a)
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node PtrDiffType
@unnumberedsec PtrDiffType
@cindex PtrDiffType

(Under construction.)

@subheading Synopsis

@example
type
  PtrDiffType  @{ built-in type @}
@end example

@subheading Description

@samp{PtrDiffType} is a (signed) integer type to represent the
difference between two positions in memory. It is not needed except
for rather low-level purposes.

@subheading Conforming to

@subheading Example

@example
program PtrDiffTypeDemo;
var
  a: array [1 .. 10] of Integer;
  d: PtrDiffType;
  p, q: Pointer;
begin
  p := @@a[1];
  q := @@a[4];
  @{$X+@}
  d := q - p
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node PtrInt
@unnumberedsec PtrInt
@cindex PtrInt

(Under construction.)

@subheading Synopsis

@example
type
  PtrCard = Integer (BitSizeOf (Pointer));
@end example

@subheading Description

A signed integer type of the same size as a pointer.

@subheading Conforming to

@subheading Example

@example
program PtrIntDemo;
var
  a: PtrInt;
  p: Pointer;
begin
  GetMem (p, 10);
  a := PtrInt (p);
  Inc (a);
  p := Pointer (a)
end.
@end example


@subheading See also


@c ----------------------------------------------------------------------------


@node PtrWord
@unnumberedsec PtrWord
@cindex PtrWord

(Under construction.)

@subheading Synopsis

@example
type
  PtrWord = PtrCard;
@end example

@subheading Description

An unsigned integer type of the same size as a pointer.

@subheading Conforming to

@subheading Example

@example
program PtrWordDemo;
var
  a: PtrWord;
  p: Pointer;
begin
  GetMem (p, 10);
  a := PtrWord (p);
  Inc (a);
  p := Pointer (a)
end.
@end example


@subheading See also


@c ----------------------------------------------------------------------------


@node public
@unnumberedsec public
@cindex public

(Under construction.)

@subheading Synopsis

@subheading Description

GPC currently accepts but ignores the @samp{public} directive in
object type declarations.

@subheading Conforming to

@subheading Example

@subheading See also

@ref{private}, @ref{protected}, @ref{published}.


@c ----------------------------------------------------------------------------


@node published
@unnumberedsec published
@cindex published

(Under construction.)

@subheading Synopsis

@subheading Description

GPC currently accepts but ignores the @samp{published} directive
in object type declarations.

@subheading Conforming to

@subheading Example

@subheading See also

@ref{private}, @ref{protected}, @ref{public}.


@c ----------------------------------------------------------------------------


@node Put
@unnumberedsec Put
@cindex Put

(Under construction.)

@subheading Synopsis

@example
procedure Put (var F: @var{typed file});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node qualified
@unnumberedsec qualified
@cindex qualified

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Random
@unnumberedsec Random
@cindex Random

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Randomize
@unnumberedsec Randomize
@cindex Randomize

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Re
@unnumberedsec Re
@cindex Re

@subheading Synopsis

@example
function Re (z: Complex): Real;
@end example

@subheading Description

@samp{Re} extracts the real part of the complex number @samp{z}.

@subheading Conforming to

@samp{Re} is an ISO-10206 Extended Pascal extension.

@subheading Example

@example
program ReDemo;
var
  z: Complex;
begin
  z := Cmplx (1, 2);
  WriteLn (Re (z) : 0 : 5)
end.
@end example

@subheading See also

@ref{Cmplx}, @ref{Im}, @ref{Arg}


@c ----------------------------------------------------------------------------


@node Read
@unnumberedsec Read
@cindex Read

(Under construction.)

@subheading Synopsis

@example
procedure Read (var F: @var{typed file}; @var{variable});
@end example
or
@example
procedure Read (var F: Text; @var{variables});
@end example
or
@example
procedure Read (@var{variables});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node ReadLn
@unnumberedsec ReadLn
@cindex ReadLn

(Under construction.)

@subheading Synopsis

@example
procedure ReadLn (var F: Text; @var{variables});
@end example
or
@example
procedure ReadLn (@var{variables});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node ReadStr
@unnumberedsec ReadStr
@cindex ReadStr

(Under construction.)

@subheading Synopsis

@example
procedure ReadStr (const S: String; @var{variables});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Real
@unnumberedsec Real
@cindex Real

(Under construction.)

@subheading Synopsis

@example
type
  Real  @{ built-in type @}
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program RealDemo;
var
  a: Real;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node record
@unnumberedsec record
@cindex record

@subheading Synopsis

In type definitions:
@example
@var{record type identifier} = record
  @var{field identifier}: @var{type definition}
  @dots{}
  @var{field identifier}: @var{type definition}
end;
@end example

or, with a variant part,

@example
@var{record type identifier} = record
  @var{field identifier}: @var{type definition}
  @dots{}
  @var{field identifier}: @var{type definition}
  case bar: @var{variant type} of
    @var{selector}: (@var{field declarations});
    @var{selector}: (@var{field declarations});
    @dots{}
end;
@end example

or, without a variant selector field,

@example
@var{record type identifier} = record
  @var{field identifier}: @var{type definition}
  @dots{}
  @var{field identifier}: @var{type definition}
  case @var{variant type} of
    @var{selector}: (@var{field declarations});
    @var{selector}: (@var{field declarations});
    @dots{}
end;
@end example

@subheading Description

The reserved word @samp{record} starts the definition of a new record type.

Records can be @samp{packed} to save memory usage at the expense of speed.

The variants of a variant record may -- but are not required to --
share one location in memory (inside the record).

Sometimes variant records are used to emulate type casting in
ISO-7185 Pascal. This is in fact a violation of the
standard and not portable. There is intentionally @emph{no}
possibility in ISO-7185 Pascal to emulate type casting.

@subheading Conforming to

The reserved word @samp{record} and record types are defined in
ISO-7185 Pascal.

According to ISO Pascal, the variant type must be an identifier.
GNU Pascal, like UCSD and Borland Pascal, also allows a subrange here.

Subranges in the variant fields, e.g. @code{case Integer of 2 .. 5},
are a GPC extension.

@subheading Example

@example
program RecordDemo;

type
  FooPtr = ^Foo;

  Foo = record
    Bar: Integer;
    NextFoo: fooPtr;
    case Choice: 1 .. 3 of
      1: (a: Integer);  @{ These three choices may share @}
      2: (b: Real);     @{ one location in memory. @}
      3: (c: Char;
          d: Boolean);
  end;

  SmallFoo = packed record
    b: 0 .. 3;
    a: Integer (5);
    r: Boolean
  end;  @{ needs 1 byte @}

var
  f: Foo;

begin
  f.b := 3.14;
  WriteLn (f.a)  @{ yields some strange number which is part of the   @}
                 @{ internal representation of the real number `f.b'. @}
end.
@end example

@subheading See also

@ref{packed}, @ref{case Statement}


@c ----------------------------------------------------------------------------


@node register
@unnumberedsec register
@cindex register

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Release
@unnumberedsec Release
@cindex Release

(Under construction.)

@subheading Synopsis

@example
procedure Release (P: Pointer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Rename
@unnumberedsec Rename
@cindex Rename

(Under construction.)

@subheading Synopsis

@example
procedure Rename (var F: @var{any file}; NewName: String);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node repeat
@unnumberedsec repeat
@cindex repeat

@subheading Synopsis

@example
repeat
  @var{statement};
  @dots{}
  @var{statement};
until @var{boolean expression};
@end example

@subheading Description

The @samp{repeat @dots{} until} statement declares a loop.  For
further description see @ref{repeat Statement}.

@subheading Conforming to

@samp{repeat} is defined in ISO-7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@example
program RepeatDemo;
var
  Number, Sum: Integer;
begin
  WriteLn ('Black Jack for beginners.');
  WriteLn ('You can choose your cards yourself. :-)');
  Sum := 0;
  repeat
    Write ('Your card (number)? ');
    ReadLn (Number);
    Inc (Sum, Number);
    WriteLn ('You have ', Sum, '.')
  until Sum >= 21;
  if Sum = 21 then
    WriteLn ('You win!')
  else
    WriteLn ('You lose.')
end.
@end example

@subheading See also

@ref{while Statement}, @ref{for Statement}


@c ----------------------------------------------------------------------------


@node Reset
@unnumberedsec Reset
@cindex Reset

(Under construction.)

@subheading Synopsis

@example
procedure Reset (var F: @var{any file}; [FileName: String;]
                                    [BlockSize: Cardinal]);
@end example

@subheading Description

@samp{Reset} opens an existing file for reading. The file pointer is
positioned at the beginning of the file.

Like @samp{Rewrite}, @samp{Append} and @samp{Extend} do,
@samp{Reset} accepts an optional second and third parameter for the
name of the file in the filesystem and, for untyped files, the block
size of the file. (For details, see @ref{Rewrite}.)

@subheading Conforming to

@samp{Reset} is defined in ISO-7185 Pascal.
The @samp{BlockSize} parameter is a Borland Pascal extension.
The @samp{FileName} parameter is a GNU extension. @c @@@@ Other compilers?

@subheading Example

@example
program ResetDemo;
var
  Sample: Text;
  s: String (42);
begin
  Rewrite (Sample);  @{ Open an internal file for writing @}
  WriteLn (Sample, 'Hello, World!');
  Reset (Sample);  @{ Open it again for reading @}
  ReadLn (Sample, s);
  WriteLn (s);
  Close (Sample)
end.
@end example

@subheading See also

@ref{Assign}, @ref{Rewrite}, @ref{Append}, @ref{Extend}.

@c ----------------------------------------------------------------------------


@node resident
@unnumberedsec resident
@cindex resident

Not yet implemented.

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node restricted
@unnumberedsec restricted
@cindex restricted

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Result
@unnumberedsec Result
@cindex Result

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Return
@unnumberedsec Return
@cindex Return

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node ReturnAddress
@unnumberedsec ReturnAddress
@cindex ReturnAddress

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Rewrite
@unnumberedsec Rewrite
@cindex Rewrite

(Under construction.)

@subheading Synopsis

@example
procedure Rewrite (var F: @var{any file}; [FileName: String;]
                                    [BlockSize: Cardinal]);
@end example

@subheading Description

@samp{Rewrite} opens a file for writing. If the file does not exist,
it is created. The file pointer is positioned at the beginning of
the file.

Like @samp{Reset}, @samp{Append} and @samp{Extend} do,
@samp{Rewrite} accepts an optional second and third parameter.

The second parameter can specify the name of the file in the
filesystem. If it is omitted, the following alternative ways can be
used to specify the name. There are so many different ways in order
to be compatible to the idiosyncrasies of as many other Pascal
compilers as possible. (If you know about yet other ways, let us
know @dots{})

@itemize @minus
@item The @samp{Assign} procedure (@pxref{Assign})
@item The @samp{Bind} procedure (@pxref{Bind})
@end itemize

The following ways are only available if the file is external, i.e.
a global variable which is mentioned in the program header.
Otherwise, the file will be internal, i.e. get no name in the file
system (it may get a name temporarily, but will then be erased
automatically again). This is useful to store some data and read
them back within a program without the need for permanent storage.

@itemize @minus
@item A command-line parameter of the form
@samp{--gpc-rts=-n@var{f}:@var{name}} where @var{f} is the
identifier of the file variable.
@item If the file was mentioned in the program header and the option
@samp{--transparent file names} (@pxref{GPC Command Line Options})
was set, the file name will be identical to the identifier converted
to lower-case.
@item Otherwise, the user will be prompted for a file name.
@end itemize

The last optional parameter determines the block size of the file.
It is valid only for untyped files. Almost always, 1 is the most
reasonable value here. However, the existence of this parameter is a
BP compatibility feature, and in BP it defaults to 128 because of
historic misdesign. Therefore, GPC requires this parameter to be
present. In @samp{--borland-pascal} mode, it makes it optional (like
BP does), but warns about the strange default if omitted.

@subheading Conforming to

@samp{Rewrite} is defined in ISO-7185 Pascal.
The @samp{BlockSize} parameter is a Borland Pascal extension.
The @samp{FileName} parameter is a GNU extension. @c @@@@ Other compilers?

@subheading Example

@example
program RewriteDemo;
var
  Sample: Text;
begin
  Assign (Sample, 'sample.txt');
  Rewrite (Sample);
  WriteLn (Sample, 'Hello, World!');
  Close (Sample)
end.
@end example

@subheading See also

@ref{Assign}, @ref{Reset}, @ref{Append}, @ref{Extend}, @ref{Update}.


@c ----------------------------------------------------------------------------


@node RmDir
@unnumberedsec RmDir
@cindex RmDir

@subheading Synopsis

@example
procedure RmDir (Directory: String);
@end example

@subheading Description

@samp{RmDir} removes the given @var{Directory} if its argument is a valid
parameter to the related operating system's function. Otherwise a
runtime error is caused.

@subheading Conforming to

@samp{RmDir} is a Borland Pascal extension.

@subheading Example

@example
program RmDirDemo;
var
  Foo: String (127);
begin
  WriteLn ('Enter directory name to remove: ');
  ReadLn (Foo);
  @{$i-@}                     @{ Suppress exit on error @}
  RmDir (Foo);
  if IOResult <> 0 then
    WriteLn ('Directory ', foo, ' could not be removed.')
  else
    WriteLn ('Okay.')
end.
@end example

@subheading See also

@ref{ChDir}, @ref{MkDir}


@c ----------------------------------------------------------------------------


@node Root
@unnumberedsec Root
@cindex Root

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Round
@unnumberedsec Round
@cindex Round

@subheading Synopsis

@example
function Round (x: Real): Integer;
@end example

@subheading Description

@samp{Round} returns the nearest integer to @samp{x}. The result is of
type integer. In the case of equidistance, the result is machine-dependent
(or depends on the behaviour of the processor).

@subheading Conforming to

@samp{Round} is defined in ISO-7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@example
program RoundDemo;
var
  Foo: Real;
begin
  foo := 9.876543;
  WriteLn (Round (Foo));  @{ Prints 10 @}
  foo := 3.456789;
  WriteLn (Round (Foo))   @{ Prints 3 @}
end.
@end example

@subheading See also

@ref{Round}


@c ----------------------------------------------------------------------------


@node RunError
@unnumberedsec RunError
@cindex RunError

(Under construction.)

@subheading Synopsis

@example
procedure RunError (ErrorCode: Integer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Seek
@unnumberedsec Seek
@cindex Seek

(Under construction.)

@subheading Synopsis

@example
procedure Seek (var F: @var{typed file}; NewPosition: Integer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SeekRead
@unnumberedsec SeekRead
@cindex SeekRead

(Under construction.)

@subheading Synopsis

@example
procedure SeekRead (var F: @var{typed file}; NewPosition: Integer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SeekUpdate
@unnumberedsec SeekUpdate
@cindex SeekUpdate

(Under construction.)

@subheading Synopsis

@example
procedure SeekUpdate (var F: @var{typed file}; NewPosition: Integer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SeekWrite
@unnumberedsec SeekWrite
@cindex SeekWrite

(Under construction.)

@subheading Synopsis

@example
procedure SeekWrite (var F: @var{typed file}; NewPosition: Integer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node segment
@unnumberedsec segment
@cindex segment

Not yet implemented.

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Self
@unnumberedsec Self
@cindex Self

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node set
@unnumberedsec set
@cindex set

(Under construction.)

@subheading Synopsis

In type definitions:
@example
set of @var{Type}  @{ built-in type class @}
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SetFileTime
@unnumberedsec SetFileTime
@cindex SetFileTime

@example
procedure SetFileTime (var f: @var{any file};
                       AccessTime, ModificationTime: UnixTimeType);
@end example

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{SetFileTime} is a GNU extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SetLength
@unnumberedsec SetLength
@cindex SetLength

@subheading Synopsis

@example
procedure SetLength (var S: String; NewLength: Integer);
@end example

@subheading Description

@samp{SetLength} explicitly assigns a new length @samp{NewLength} to the
string parameter @code{S}.  The contents of the string is @emph{not} changed;
if the operation increases the length of the string, the characters appended
at the end are @emph{undefined}.

@subheading Conforming to

@samp{SetLength} is a Borland Delphi 2.0 extension.

@subheading Example

@example
program SetLengthDemo;

var
  S: String (26);

begin
  S := 'Hello, world!';
  SetLength (S, Length ('Hello'));
  WriteLn (S);                                           @{ 'Hello' @}

  SetLength (S, 26);
  WriteLn (S);                     @{ 'Hello, world!(%$xy"!#&~+(/]' @}
                            @{ undefined characters ^^^^^^^^^^^^^^  @}

  SetLength (S, 42);       @{ The overflow is *not* (yet) detected. @}
  WriteLn (S);        @{ This might cause a runtime error or crash. @}
end.
@end example

@subheading See also

@ref{Length}, @ref{String}.


@c ----------------------------------------------------------------------------


@node SetType
@unnumberedsec SetType
@cindex SetType

@subheading Synopsis

@example
procedure SetType (var SomeObject; VMT: PObjectType);
@end example

@subheading Description

The procedure @samp{SetType} explicitly assigns a value to the
implicit VMT field of an object. This is normally done implicitly
when a constructor is called.

You can use this to write a polymorphic I/O routine which reads an
object from a file. In this case, you cannot reasonably use
@samp{New} to allocate the storage, but you @samp{GetMem} it and
initialize the object manually using @samp{SetType} before calling
the constructor explicitly.

The only values you should assign to an object via @samp{SetType}
are actual VMT pointers that were obtained via @samp{TypeOf}. In
particular, declaring a record like the one shown in the description
of @samp{PObjectType} and assigning a pointer to it to an object via
@samp{SetType} will usually not work because the virtual method
pointers are missing.

Since @samp{SetType} is a dangerous feature, it yields a warning
unless @samp{@{$X+@}} is given.

@subheading Conforming to

@samp{SetType} is a GNU extension.

@subheading Example

@example
program SetTypeDemo;

type
  BasePtr = ^BaseObj;

  BaseObj = object
    constructor Load;
  end;

  ChildObj = object (BaseObj)
    constructor Load;
  end;

constructor BaseObj.Load;
begin
end;

constructor ChildObj.Load;
begin
end;

@{$X+@}

@{ This is somewhat fragmentary code. @}
function GetObject (var InputFile: File) = Result: BasePtr;
const
  VMTTable: array [1 .. 2] of PObjectType =
    (TypeOf (BaseObj), TypeOf (ChildObj));
var
  Size: Cardinal;
  TypeID: Integer;
  VMT: PObjectType;
begin
  @{ Read the size of the object from some file and store it in `Size'. @}
  BlockRead (InputFile, Size, SizeOf (Size));

  @{ Allocate memory for the object. @}
  GetMem (Result, Size);

  @{ Read some ID from some file. @}
  BlockRead (InputFile, TypeID, SizeOf (TypeID));

  @{ Look up the `VMT' from some table. @}
  @{ Range checking wouldn't be a bad idea here ... @}
  VMT := VMTTable[TypeID];

  SetType (Result^, VMT);

  @{ Now the object is ready, and the constructor can be called. @}
  @{ Look up the correct constructor from some table and call it. @}
end;

begin
end.
@end example

@subheading See also

@ref{PObjectType}, @ref{TypeOf}, @ref{OOP}.


@c ----------------------------------------------------------------------------


@node shl
@unnumberedsec shl
@cindex shl

@subheading Synopsis

@example
operator shl (operand1, operand2: @var{integer type}) = Result: @var{integer type};
@end example
or
@example
procedure shl (var operand1: @var{integer type}; operand2: @var{integer type});
@end example

@subheading Description

In GNU Pascal, @samp{shl} has two built-in meanings:

@enumerate

@item
Bitwise shift left of an integer-type expression by another integer value.
The result is of the type of the first operand.

@item
Use as a ``procedure'':  @samp{operand1} is shifted left by
@samp{operand2}; the result is stored in @samp{operand1}.

@end enumerate

@subheading Conforming to

@samp{shl} is a Borland Pascal extension.

Use of @samp{shl} as a ``procedure'' is a GNU Pascal extension.

@subheading Example

@example
program ShlDemo;
var
  a: Integer;
begin
  a := 1 shl 7;  @{ yields 128 = 2 pow 7 @}
  shl (a, 4)  @{ same as `a := a shl 4' @}
end.
@end example

@subheading See also

@ref{shr}, @ref{Operators}.


@c ----------------------------------------------------------------------------


@node ShortBool
@unnumberedsec ShortBool
@cindex ShortBool

(Under construction.)

@subheading Synopsis

@example
type
  ShortBool = Boolean (BitSizeOf (ShortInt));
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program ShortBoolDemo;
var
  a: ShortBool;
begin
  ShortInt (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node ShortCard
@unnumberedsec ShortCard
@cindex ShortCard

@subheading Synopsis

@example
type
  ShortCard = Cardinal (BitSizeOf (ShortInt));
@end example

@subheading Description

@samp{ShortCard} is an unsigned integer type which is not larger than
@samp{Cardinal}.  On most platforms it is 16 bits wide and thus has a
range of @samp{0..65535}.

@samp{ShortCard} in GNU Pascal is compatible to @samp{short unsigned int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{ShortCard} is a GNU Pascal extension.

@subheading Example

@example
program ShortCardDemo;
var
  a: ShortCard;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node ShortInt
@unnumberedsec ShortInt
@cindex ShortInt

@subheading Synopsis

@example
type
  ShortInt  @{ built-in type @}
@end example

@subheading Description

@samp{ShortInt} is a signed integer type which is not larger than
@samp{Integer}.  On most platforms it is 16 bits wide and thus has a
range of @samp{-32768..32767}.

@samp{ShortInt} in GNU Pascal is compatible to @samp{short int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{ShortInt} is a Borland Pascal extension. In Borland
Pascal, @samp{ShortInt} is an 8-bit signed integer type
(@samp{ByteInt} in GNU Pascal).

@subheading Example

@example
program ShortIntDemo;
var
  a: ShortInt;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node ShortReal
@unnumberedsec ShortReal
@cindex ShortReal

(Under construction.)

@subheading Synopsis

@example
type
  ShortReal  @{ built-in type @}
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program ShortRealDemo;
var
  a: ShortReal;
begin
  a := 42;
  WriteLn (a)
end.
@end example


@subheading See also


@c ----------------------------------------------------------------------------


@node ShortWord
@unnumberedsec ShortWord
@cindex ShortWord

@subheading Synopsis

@example
type
  ShortWord = ShortCard;
@end example

@subheading Description

@samp{ShortWord} is an unsigned integer type which is not larger than
@samp{Word}.  On most platforms it is 16 bits wide and thus has a range of
of @samp{0..65535}.  It is the same as @ref{ShortCard}.

@samp{ShortWord} in GNU Pascal is compatible to @samp{short unsigned int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{ShortWord} is a GNU Pascal extension.

@samp{ShortWord} in GNU Pascal essentially corresponds to @samp{Word} in
Borland Pascal and Delphi where it is a 16-bit unsigned integer type.

@subheading Example

@example
program ShortWordDemo;
var
  a: ShortWord;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node shr
@unnumberedsec shr
@cindex shr

@subheading Synopsis

@example
operator shr (operand1, operand2: @var{integer type}) = Result: @var{integer type};
@end example
or
@example
procedure shr (var operand1: @var{integer type}; operand2: @var{integer type});
@end example

@subheading Description

In GNU Pascal, @samp{shr} has two built-in meanings:

@enumerate

@item
Bitwise shift right of an integer-type expression by another integer value.
The result is of the type of the first operand.

@item
Use as a ``procedure'':  @samp{operand1} is shifted right by
@samp{operand2}; the result is stored in @samp{operand1}.

@end enumerate

@subheading Conforming to

@samp{shr} is a Borland Pascal extension.

Unlike the Borland compilers, GNU Pascal cares about the
signedness of the first operand:  If a signed integer with a
negative value is shifted right, ``one'' bits are filled in from
the left.

Use of @samp{shr} as a ``procedure'' is a GNU Pascal extension.

@subheading Example

@example
program ShrDemo;
var
  a: Integer;
begin
  a := 1024 shr 4;  @{ yields 64 @}
  a := -127 shr 4;  @{ yields -8 @}
  shr (a, 2)  @{ same as `a := a shr 2' @}
end.
@end example

@subheading See also

@ref{shl}, @ref{Operators}.


@c ----------------------------------------------------------------------------


@node Sin
@unnumberedsec Sin
@cindex Sin

@subheading Synopsis

@example
function Sin (x: Real): Real;
@end example
or
@example
function Sin (z: Complex): Complex;
@end example

@subheading Description

@samp{Sin} returns the sine of the argument.
The result is in the range @samp{-1 <= Sin (x) <= 1} for real arguments.

@subheading Conforming to

The function @samp{Sin} is defined in ISO-7185 Pascal;
its application to complex values is defined in ISO-10206 Extended Pascal.

@subheading Example

@example
program SinDemo;
begin
  WriteLn (Sin (SqRt (2) / 2) : 0 : 5)
  @{ yields 0.5 since Sin (SqRt (2) /2) = 0.5 @}
end.
@end example

@subheading See also

@ref{ArcTan}, @ref{Cos}, @ref{Ln}, @ref{Arg}.


@c ----------------------------------------------------------------------------


@node Single
@unnumberedsec Single
@cindex Single

(Under construction.)

@subheading Synopsis

@example
type
  Single = ShortReal;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SizeOf
@unnumberedsec SizeOf
@cindex SizeOf

@subheading Synopsis

@example
function SizeOf (var x): SizeType;
@end example

@subheading Description

Returns the size of a type or variable in bytes.

@samp{SizeOf} can be applied to expressions and type names. If the
argument is a polymorphic object, the size of its actual type is
returned.

@subheading Conforming to

@samp{SizeOf} is a UCSD Pascal extension.

@subheading Example

@example
program SizeOfDemo;
var
  a: Integer;
  b: array [1 .. 8] of Char;
begin
  WriteLn (SizeOf (a));        @{ Size of an `Integer'; often 4 bytes. @}
  WriteLn (SizeOf (Integer));  @{ The same. @}
  WriteLn (SizeOf (b))         @{ Size of eight `Char's; usually 8 bytes. @}
end.
@end example

@subheading See also

@ref{BitSizeOf}, @ref{AlignOf}, @ref{TypeOf}.


@c ----------------------------------------------------------------------------


@node SizeType
@unnumberedsec SizeType
@cindex SizeType

@subheading Synopsis

@example
type
  SizeType  @{ built-in type @}
@end example

@subheading Description

@samp{SizeType} is an integer type (usually unsigned) to represent
the size of objects in memory.

@subheading Conforming to

@subheading Example

@example
program SizeTypeDemo;
var
  a: array [1 .. 10] of Integer;
  Size: SizeType;
begin
  Size := SizeOf (a);
  WriteLn (Size)
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node SmallInt
@unnumberedsec SmallInt
@cindex SmallInt

@subheading Synopsis

@example
type
  SmallInt = ShortInt;
@end example

@subheading Description

@samp{SmallInt} is a signed integer type which is not larger than
@samp{Integer}. On most platforms it is 16 bits wide and thus has a
range of @samp{-32768..32767}. It is the same as @samp{ShortInt}
(see @ref{ShortInt}).

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{SmallInt} is a Delphi 2.0 extension.

@subheading Example

@example
program SmallIntDemo;
var
  a: SmallInt;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{ShortInt}, @ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node Sqr
@unnumberedsec Sqr
@cindex Sqr

@subheading Synopsis

@example
function Sqr (i: @var{integer type}): @var{integer type};
@end example
or
@example
function Sqr (x: @var{real type}): @var{real type};
@end example
or
@example
function Sqr (z: @var{Complex type}): @var{Complex type};
@end example

@subheading Description

Returns the square of the argument:

@example
function Sqr (x: @var{some type}): @var{some type};
begin
  Sqr := x * x  @{ or: x pow 2 @}
end;
@end example

@subheading Conforming to

The function @samp{Sqr} is defined in ISO-7185 Pascal;
its application to complex values is defined in ISO-10206 Extended Pascal.

@subheading Example

@example
program SqrDemo;

var
  i: Complex;

begin
  i := Cmplx (0, 1);
  WriteLn (Re (Sqr (i)) : 0 : 3)  @{ yields -1.000 @}
end.
@end example

@subheading See also

@ref{pow}, @ref{SqRt}, @ref{Abs}, @ref{Operators}.


@c ----------------------------------------------------------------------------


@node SqRt
@unnumberedsec SqRt
@cindex SqRt

@subheading Synopsis

@example
function SqRt (x: @var{real type}): @var{real type};
@end example
or
@example
function SqRt (z: @var{Complex type}): @var{Complex type};
@end example

@subheading Description

Returns the positive square root of the argument.

For real arguments, it is an error if the argument is negative.

For complex arguments, @samp{SqRt} returns the principal value of
the root of the argument, i.e.@: the root with positive real part,
or, if the real part is zero, that one with positive imaginary part.

@subheading Conforming to

The function @samp{SqRt} is defined in ISO-7185 Pascal;
its application to complex values is defined in ISO-10206 Extended Pascal.

@subheading Example

@example
program SqRtDemo;

var
  m1: Complex;

begin
  m1 := Cmplx (-1, 0);  @{ -1 @}
  WriteLn (Re (SqRt (m1)) : 6 : 3, Im (SqRt (m1)) : 6 : 3);
    @{ yields 1.000 -1.000, i.e. the imaginary unit, i @}
end.
@end example

@subheading See also

@ref{pow}, @ref{Sqr}, @ref{Operators}.


@c ----------------------------------------------------------------------------


@node StandardError
@unnumberedsec StandardError
@cindex StandardError

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node StandardInput
@unnumberedsec StandardInput
@cindex StandardInput

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node StandardOutput
@unnumberedsec StandardOutput
@cindex StandardOutput

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node static
@unnumberedsec static
@cindex static

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node StdErr
@unnumberedsec StdErr
@cindex StdErr

@subheading Synopsis

@example
var
  StdErr: Text;
@end example

@subheading Description

The @samp{StdErr} variable is connected to the standard error file
handle. To report errors, you should prefer
@samp{WriteLn (StdErr, 'everything wrong')} over
@samp{WriteLn ('everything wrong')}.

@subheading Conforming to

@samp{StdErr} is a GNU Pascal extension.

@subheading Example

@example
program StdErrDemo;
var
  Denominator: Integer;
begin
  ReadLn (Denominator);
  if Denominator = 0 then
    WriteLn (StdErr, ParamStr (0), ': division by zero')
  else
    WriteLn ('1 / ', Denominator, ' = ', 1 / Denominator)
end.
@end example

@subheading See also

@ref{StandardError}, @ref{Output}, @ref{Input}.


@c ----------------------------------------------------------------------------


@node Str
@unnumberedsec Str
@cindex Str

(Under construction.)

@subheading Synopsis

@example
procedure Str (x: @var{integer or real}; var Dest: String);
@end example
or
@example
procedure Str (x: @var{integer or real} : @var{field width}; var Dest: String);
@end example
or
@example
procedure Str (x: Real : @var{field width} : @var{precision}; var Dest: String);
@end example
or
@example
procedure Str (@var{repeated constructs as described above}; var Dest: String);
@end example

@subheading Description

@subheading Conforming to

@samp{Str} is a UCSD Pascal extension, generalized by Borland
Pascal.  The possibility to handle more than one variable with
one call to @samp{Str} is a GNU Pascal extension.

ISO-10206 Extended Pascal defines @samp{WriteStr} instead of
@samp{Str}.

@subheading Example

@subheading See also

@ref{WriteStr}.


@c ----------------------------------------------------------------------------


@node String
@unnumberedsec String
@cindex String

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node String2CString
@unnumberedsec String2CString
@cindex String2CString

(Under construction.)

@subheading Synopsis

@example
function String2CString (const S: String): CString;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SubStr
@unnumberedsec SubStr
@cindex SubStr

@subheading Synopsis

@example
function SubStr (S: String; FirstChar: Integer): String;
@end example
or
@example
function SubStr (S: String; FirstChar, Count: Integer): String;
@end example

@subheading Description

@samp{SubStr} returns a sub-string of @var{S} starting with the
character at position @var{FirstChar}.  If @var{Count} is given, such
many characters will be copied into the sub-string.  If @var{Count} is
omitted, the sub-string will will range to the end of @var{S}.

If @samp{Count} is too large for the sub-string to fit in @var{S} or if
@samp{FirstChar} exceeds the length of @var{S}, @samp{SubStr} triggers a
runtime error.  (For a function returning the empty string instead, see
@ref{Copy}.)

@subheading Conforming to

@samp{SubStr} is a ISO 10206 Extended Pascal extension.

@subheading Example

@example
program SubStrDemo;
var
  S: String (42);
begin
  S := 'Hello';
  WriteLn (SubStr (S, 2, 3));   @{ yields `ell' @}
  WriteLn (SubStr (S, 3));      @{ yields `llo' @}
  WriteLn (SubStr (S, 4, 7));   @{ yields a runtime error @}
  WriteLn (SubStr (S, 42));     @{ yields a runtime error @}
end.
@end example

@subheading See also

@ref{Copy}, @ref{String Slice Access}.


@c ----------------------------------------------------------------------------


@node Succ
@unnumberedsec Succ
@cindex Succ

@subheading Synopsis

@example
function Succ (i: @var{ordinal type}): @var{ordinal type};
@end example
or
@example
function Succ (i: @var{ordinal type}; j: Integer): @var{ordinal type};
@end example

or, with extended syntax (@samp{--extended-syntax} or @samp{@{$X+@}}),

@example
function Succ (p: @var{Pointer type}): @var{Pointer type};
@end example
or
@example
function Succ (p: @var{Pointer type}; j: Integer): @var{Pointer type};
@end example

@subheading Description

Returns the successor of the @var{ordinal type} value @samp{i}, or, if the
second argument @samp{j} is given, its @samp{j}th successor.  For integer
values @samp{i}, this is @samp{i + 1} (or @samp{i + j}).  (No, @samp{Succ}
does @emph{not} work faster than plain addition.  Both are optimized to a
single machine instruction or even expanded by the compiler, if possible.)

If extended syntax is on, the argument may also be a pointer value.  In this
case, the address is incremented by the size of the variable pointed to, or,
if @samp{j} is given, by @samp{j} times the size of the variable pointed to.
If @samp{p} points to an element of an array, the returned pointer will point
to the (@samp{j}th) next element of the array.

@subheading Conforming to

The @samp{Succ} function is defined in ISO-7185 Pascal.  The optional
second parameter is defined in ISO-10206 Extended Pascal.  Application of
@samp{Succ} to pointers is defined in Borland Pascal.  The combination of the
second argument with application to pointers is a GNU extension.

@subheading Example

@example
program SuccDemo;

type
  Metasyntactical = (foo, bar, baz);

var
  m: Metasyntactical;
  c: Char;
  a: array [1 .. 7] of Integer;
  p: ^Integer;

begin
  m := Succ (foo);     @{ bar @}
  c := Succ ('A', 4);  @{ 'E' @}
  a[1] := 42;
  a[2] := Succ (a[1]);     @{ 43 @}
  a[5] := Succ (a[2], 7);  @{ 50 @}
  @{$X+@}
  p := @@a[1];
  p := Succ (p);     @{ points to `a[2]' now @}
  p := Succ (p, 3);  @{ points to `a[5]' now @}
end.
@end example

@subheading See also

@ref{Pred}, @ref{Inc}, @ref{Pointer Arithmetics}.


@c ----------------------------------------------------------------------------


@node Text
@unnumberedsec Text
@cindex Text

(Under construction.)

@subheading Synopsis

@example
type
  Text  @{ built-in type @}
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program TextDemo;
var
  t: Text;
begin
  Rewrite (t, 'hello.txt');
  WriteLn (t, 'Hello, world!')
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node TextWritable
@unnumberedsec TextWritable
@cindex TextWritable

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node then
@unnumberedsec then
@cindex then

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@example
program ThenDemo;
var
  i: Integer;
begin
  Write ('Enter a number: ');
  ReadLn (i);
  if i > 42 then
    WriteLn ('The number is greater than 42')
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node Time
@unnumberedsec Time
@cindex Time

(Under construction.)

@subheading Synopsis

@example
function Time (T: TimeStamp): packed array [1 .. @var{Time Length}] of Char;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node TimeStamp
@unnumberedsec TimeStamp
@cindex TimeStamp

(Under construction.)

@subheading Synopsis

@example
type
  TimeStamp = @{@@@@packed@} record
    DateValid,
    TimeValid  : Boolean;
    Year       : Integer;
    Month      : 1 .. 12;
    Day        : 1 .. 31;
    DayOfWeek  : 0 .. 6;  @{ 0 means Sunday @}
    Hour       : 0 .. 23;
    Minute     : 0 .. 59;
    Second     : 0 .. 61; @{ to allow for leap seconds @}
    MicroSecond: 0 .. 999999;
    TimeZone   : Integer; @{ in seconds @}
    DST        : Boolean;
    TZName1,
    TZName2    : String (32);
  end;
@end example

(@@@@ Currently, in GPC, TimeStamp is not actually packed.)

The fields @samp{DateValid}, @samp{TimeValid}, @samp{Year},
@samp{Month}, @samp{Day}, @samp{Hour}, @samp{Minute}, @samp{Second}
are required by Extended Pascal, the other ones are extensions.

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node to
@unnumberedsec to
@cindex to

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node to begin do
@unnumberedsec to begin do
@cindex to begin do

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node to end do
@unnumberedsec to end do
@cindex to end do

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Trim
@unnumberedsec Trim
@cindex Trim

(Under construction.)

@subheading Synopsis

@example
function Trim (S: String): String;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node True
@unnumberedsec True
@cindex True

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Trunc
@unnumberedsec Trunc
@cindex Trunc

@subheading Synopsis

@example
function Trunc (x: Real): Integer;
@end example

@subheading Description

@samp{Trunc} converts @samp{x} to the next integer below its
argument (i.e.@: truncates the numbers after the point).

@subheading Conforming to

@samp{Trunc} is defined in ISO-7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@example
program TruncDemo;
var
  Foo: Real;
begin
  Foo := 9.876;
  WriteLn (Trunc (Foo))  @{ Prints 9 @}
end.
@end example

@subheading See also

@ref{Round}.


@c ----------------------------------------------------------------------------


@node Truncate
@unnumberedsec Truncate
@cindex Truncate

(Under construction.)

@subheading Synopsis

@example
procedure Truncate (var F: @var{any file});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node type
@unnumberedsec type
@cindex type

@subheading Synopsis

As a type declaration:
@example
type
  @var{type indentifier} = @var{type definition};
@end example
or with initialization:
@example
type
  @var{type indentifier} = @var{type definition} value @var{constant expression};
@end example


@subheading Description

The reserved word @samp{type} starts the declaration of a @var{type
identifier} which is defined by @var{type definition}.  For further
description see @ref{Type Declaration}, @ref{Type Declaration},
@ref{Type Definition}, @ref{Data Types}.

@subheading Conforming to

@samp{type} is defined in ISO-7185 Pascal and supported
by all known Pascal variants. Initializers are an ISO-10206 Extended
Pascal extension.

@subheading Example

@example
program TypeDemo;
type
  @{ This side is the @}    @{ That side is the @}
  @{ type declaration @}    @{ type definition  @}

  @{ array type @}
  ArrayType                  = array [0 .. 9] of Integer;

  @{ record type @}
  RecordType                 = record
                                 Bar: Integer
                               end;

  @{ subrange type @}
  SubrangeType               = -123 .. 456;

  @{ enumeration type @}
  EnumeratedType             = (Mon, Tue, Wed, Thu, Fri,  Sat, Sun);

  @{ set type @}
  CharSetType                = set of Char;

  @{ object type @}
  ObjectType                 = object
                                 constructor Init;
                                 procedure Method;
                                 destructor Done
                               end;

  @{ pointer type to another type identifier @}
  PArrayType                 = ^ArrayType;

  @{ an alias name for another type identifier @}
  IntegerType                = Integer;

  @{ an integer which is initialized by 123 @}
  InitializedInt             = Integer value 123;

  @{ a schema with discriminants x and y of type Integer @}
  SchemaType (x, y: Integer) = array [x .. y] of Integer;

begin
end.
@end example

@subheading See also

@ref{Type Declaration}, @ref{Type Definition}, @ref{Data Types},
@ref{Variable Declaration}, @ref{array}, @ref{record}, @ref{object},
@ref{set}, @ref{Pointer}, @ref{value}.


@c ----------------------------------------------------------------------------


@node type of
@unnumberedsec type of
@cindex type of

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node TypeOf
@unnumberedsec TypeOf
@cindex TypeOf

@subheading Synopsis

@example
function TypeOf (var x): PObjectType;
@end example

@subheading Description

Returns a pointer to the VMT of an @emph{object} type or variable.
This pointer can be used to identify the type of an object.

@samp{TypeOf} can be applied to expressions of object type and to
object type names. In the former case, the actual type of
polymorphic objects is returned.

@subheading Conforming to

ISO Pascal does not define @samp{TypeOf}, Borland Pascal does.

@subheading Example

@example
program TypeOfDemo;
type
  FooPtr = ^Foo;
  BarPtr = ^Bar;

  Foo = object         @{ Has a VMT, though it doesn't @}
    x: Integer;        @{ contain virtual methods.     @}
    constructor Init;
  end;

  Bar = object (Foo)
    y: Integer;
  end;

constructor Foo.Init;
begin
end;

var
  MyFoo: FooPtr;

begin
  MyFoo := New (BarPtr, Init);
  if TypeOf (MyFoo^) = TypeOf (Bar) then  @{ True @}
    WriteLn ('OK')
end.
@end example

@subheading See also

@ref{BitSizeOf}, @ref{AlignOf}, @ref{PObjectType}, @ref{SetType}, @ref{SizeOf}, @ref{OOP}.


@c ----------------------------------------------------------------------------


@node Unbind
@unnumberedsec Unbind
@cindex Unbind

(Under construction.)

@subheading Synopsis

@example
procedure Unbind (var F: @var{any file});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node unit
@unnumberedsec unit
@cindex unit

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Unpack
@unnumberedsec Unpack
@cindex Unpack

(Under construction.)

@subheading Synopsis

@example
procedure Unpack (Source: @var{packed array};
                  var Dest: @var{unpacked array};
                  FirstElement: @var{index type});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node until
@unnumberedsec until
@cindex until

(Under construction.)

@subheading Synopsis

@subheading Description

@samp{until} is part of the @samp{repeat @dots{} until} loop statement.

@subheading Conforming to

@subheading Example

@subheading See also

@ref{repeat}, @ref{while}, @ref{for}.


@c ----------------------------------------------------------------------------


@node UpCase
@unnumberedsec UpCase
@cindex UpCase

(Under construction.)

@subheading Synopsis

@example
function UpCase (Ch: Char): Char;
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Update
@unnumberedsec Update
@cindex Update

(Under construction.)

@subheading Synopsis

@example
procedure Update (var F: @var{any file});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node uses
@unnumberedsec uses
@cindex uses

@subheading Synopsis

In a program:

@example
program @@@@fragment foo;

uses
  bar1,
  bar2 in 'baz.pas',
  bar3;

[...]
@end example

In a unit:

@example
unit @@@@fragment Bar3;

interface

uses
  bar1,
  bar2 in 'baz.pas';

[...]

implementation

uses
  bar3,
  bar4 in 'qux.pas';

[...]
@end example

@subheading Description

The reserved word @samp{uses} in the @emph{import part} of a program
or unit makes the program or unit import an interface.

The keyword @samp{in} tells GPC to look for the @samp{unit} in the
specified file; otherwise the file name is derived from the name of
the interface by adding first @file{.p}, then @file{.pas}.

There must be at most one import part in a program.

In a unit, there can be one import part in the interface part and
one in the implementation part.

The imported interface needn't be a UCSD/Borland Pascal unit, it
may be an interface exported by an Extended Pascal module as well.

@subheading Conforming to

ISO Pascal does not define @samp{uses} and units at all. UCSD and
Borland Pascal do, but without the @samp{in} extension. Delphi
supports @samp{uses} like described above.

@subheading Example

@subheading See also

@ref{unit}, @ref{module}, @ref{import}.


@c ----------------------------------------------------------------------------


@node Val
@unnumberedsec Val
@cindex Val

(Under construction.)

@subheading Synopsis

@example
procedure Val (const Source: String; var x: @var{integer or real});
@end example
or
@example
procedure Val (const Source: String; var x: @var{integer or real};
               var ErrorCode: Integer);
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node value
@unnumberedsec value
@cindex value

@subheading Synopsis

@subheading Description

The reserved word @samp{value} is part of a type or var declaration.
It can be replaced by @samp{:=} or @samp{=}.

@subheading Conforming to

@samp{value} is an ISO-10206 Extended Pascal extension. @samp{:=} in
this context is a VAX Pascal extension, and @samp{=} is a Borland
Delphi extension.

@subheading Example

@subheading See also

@ref{var}, @ref{type}, @ref{Variable Declaration}, @ref{Type Declaration}.


@c ----------------------------------------------------------------------------


@node var
@unnumberedsec var
@cindex var

@subheading Synopsis

As part of a variable declaration part or in a statement block:
@example
var @var{variable identifier}: @var{type identifier};
@end example
or
@example
var @var{variable identifier}: @var{type definition};
@end example
and with initializing value:
@example
var @var{variable identifier}: @var{type identifier} value @var{constant expression};
@end example
or
@example
var @var{variable identifier}: @var{type definition} value @var{constant expression};
@end example

@noindent
As part of a parameter list (passing by reference):
@example
var @var{var parameter}: @var{type identifier};
@end example
or without type declaration
@example
var @var{var parameter};
@end example

@noindent
or protected (i.e., the called routine can't modify the parameter):
@example
protected var @var{var parameter}: @var{type identifier};
@end example
or without type declaration
@example
protected var @var{var parameter};
@end example

@subheading Description

In a declaration part: The reserved word @samp{var} declares a
@var{variable identifier} whose type is of @var{type identifier} or
which is defined by @var{type definition}.  For further description
see @ref{Variable Declaration}, @ref{Type Declaration},
@ref{Type Definition}, @ref{Data Types}.

In a parameter list: see @ref{Subroutine Parameter List Declaration}.

@subheading Conforming to

@samp{var} is defined in ISO-7185 Pascal and supported by
all known Pascal variants. Untyped @samp{var} parameters in
parameter lists are a UCSD Pascal extension. The ability to do
@samp{var} declarations in a statement block is a GNU Pascal
extension.

@subheading Example

@example
program VarDemo;

type
  FooType = Integer;

var
  Bar: FooType;
  ArrayFoo: array [0 .. 9] of Integer;   @{ array var definition @}
  FecordFoo: record                      @{ record var definition @}
               Bar: Integer
             end;
  CharsetFoo: set of Char;               @{ set var @}
  SubrangeFoo: -123 .. 456;              @{ subrange var @}
  EnumeratedFoo: (Mon, Tue, Wed, Thu, Fri, Sat, Sun);  @{enumerated var @}
  PointerBar: ^FooType;                  @{ pointer var @}

procedure ReadFoo (var Foo: FooType);
begin
  ReadLn (Foo)
end;

begin
  var Bar: Integer;  @{ GNU Pascal extension @}
  Bar := 42
end.
@end example

@subheading See also

@ref{type}, @ref{array}, @ref{record}, @ref{set}, @ref{Subrange Types},
@ref{Pointer}, @ref{protected}.


@c ----------------------------------------------------------------------------


@node view
@unnumberedsec view
@cindex view

Not yet implemented.

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node virtual
@unnumberedsec virtual
@cindex virtual

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Void
@unnumberedsec Void
@cindex Void

(Under construction.)

@subheading Synopsis

@example
type
  Void  @{ built-in type @}
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program VoidDemo;

procedure p (var x: Void);
begin
end;

var
  i: Integer;
  s: String (42);

begin
  p (i);
  p (s)
end.
@end example


@subheading See also


@c ----------------------------------------------------------------------------


@node volatile
@unnumberedsec volatile
@cindex volatile

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node while
@unnumberedsec while
@cindex while

@subheading Synopsis

@example
while @var{boolean expression} do
  @var{statement}
@end example

@subheading Description

The @samp{while} statement declares a loop. For further description see
@ref{while Statement}.

@subheading Conforming to

@samp{while} is defined in ISO-7185 Pascal and supported by
all known Pascal variants.

@subheading Example

@example
program WhileDemo;
var
  Foo, Bar: Integer;
begin
  WriteLn ('Enter an descending series of integer numbers.');
  WriteLn ('Terminate by breaking this rule.');
  WriteLn ('Enter start number: ');
  Bar := MaxInt;
  ReadLn (Foo);
  while Foo < Bar do
    begin
      Bar := Foo;
      ReadLn (Foo)
    end;
  WriteLn ('The last number of your series was: ', Bar)
end.
@end example

@subheading See also

@ref{repeat Statement}, @ref{for Statement}


@c ----------------------------------------------------------------------------


@node with
@unnumberedsec with
@cindex with

(Under construction.)

@subheading Synopsis

@subheading Description

@emph{Note}: @samp{with} statement overwrites program namespace.

@subheading Conforming to

@subheading Example

 ...

     @{ Note bar is overwritten by foo.bar @}
 ...

@subheading See also


@c ----------------------------------------------------------------------------


@node Word
@unnumberedsec Word
@cindex Word

@subheading Synopsis

@example
type
  Word = Cardinal;
@end example
or
@example
type
  Word (n) = Cardinal (n);
@end example

@subheading Description

@samp{Word} is the ``natural'' unsigned integer type in GNU Pascal.
On most platforms it is 32 bits wide and thus has a range of
@samp{0..4294967295}.  It is the same as @ref{Cardinal}, introduced for
compatibility with other Pascal compilers.

As an extension, GPC allows to use @samp{Word} as a pseudo-schema
to produce types with a specified size in bits; for example

@example
type
  Word16 = Cardinal (16);
@end example

defines an unsigned integer type with 16 bits.  The same mechanism
works for @samp{Cardinal} and @samp{Integer}, too.

@samp{Word} in GNU Pascal is compatible to @samp{unsigned int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

ISO Pascal does not define @samp{Cardinal}.
(However see @ref{Subrange Types}.)

The @samp{Word} type appears in Borland Pascal and Delphi, too, where
it is a 16-bit unsigned integer type.

@subheading Example

@example
program WordDemo;
var
  a: Word;
begin
  a := 42;
  WriteLn (a)
end.
@end example

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node WordBool
@unnumberedsec WordBool
@cindex WordBool

(Under construction.)

@subheading Synopsis

@example
type
  WordBool = Boolean (BitSizeOf (Word));
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@example
program WordBoolDemo;
var
  a: WordBool;
begin
  Word (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end example

@subheading See also


@c ----------------------------------------------------------------------------


@node Write
@unnumberedsec Write
@cindex Write

(Under construction.)

@subheading Synopsis

@example
procedure Write (var F: @var{typed file}; @var{variable});
@end example
or
@example
procedure Write (var F: Text; @var{values and format specifications});
@end example
or
@example
procedure Write (@var{values and format specifications});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node WriteLn
@unnumberedsec WriteLn
@cindex WriteLn

(Under construction.)

@subheading Synopsis

@example
procedure WriteLn (var F: Text; @var{values and format specifications});
@end example
or
@example
procedure WriteLn (@var{values and format specifications});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node WriteStr
@unnumberedsec WriteStr
@cindex WriteStr

(Under construction.)

@subheading Synopsis

@example
procedure WriteStr (var Dest: String; @var{values and format specifications});
@end example

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node xor
@unnumberedsec xor
@cindex xor

@subheading Synopsis

@example
operator xor (operand1, operand2: Boolean) = Result: Boolean;
@end example
or
@example
operator xor (operand1, operand2: @var{integer type}) = Result: @var{integer type};
@end example
or
@example
procedure xor (var operand1: @var{integer type}; operand2: @var{integer type});
@end example

@subheading Description

In GNU Pascal, @samp{xor} has three built-in meanings:

@enumerate

@item
Logical ``exclusive or'' between two @samp{Boolean}-type expressions.
The result of the operation is of @samp{Boolean} type.  (Logical @samp{foo xor
bar} in fact has the same effect as @samp{foo <> bar}.)

@item
Bitwise ``exclusive or'' between two integer-type expressions.
The result is of the common integer type of both expressions.

@item
Use as a ``procedure'':  @samp{operand1} is ``xor''ed bitwise with
@samp{operand2}; the result is stored in @samp{operand1}.

@end enumerate

@subheading Conforming to

ISO Pascal does not define the @samp{xor} operator;
Borland Pascal and Delphi do.

Use of @samp{xor} as a ``procedure'' is a GNU extension.

@subheading Example

@example
program XorDemo;
var
  a, b, c: Integer;
begin
  if (a = 0) xor (b = 0) then
    c := 1  @{ happens if either `a' or `b' is zero,    @}
            @{ but not if both are zero or both nonzero @}
  else if a xor b = 0 then  @{ bitwise xor @}
    c := 2  @{ happens if a = b @}
  else
    xor (c, a)  @{ same as `c := c xor a' @}
end.
@end example

@subheading See also

@ref{and}, @ref{or}, @ref{Operators}.


@c ============================================================================
